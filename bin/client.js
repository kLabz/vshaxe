// Generated by Haxe 4.0.0-rc.2+77d7809
(function ($hx_exports, $global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	split(s) {
		return s.replace(this.r,"#__delim__#").split("#__delim__#");
	}
}
EReg.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		var x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		var i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static iter(a) {
		return { cur : 0, arr : a, hasNext : function() {
			return this.cur < this.arr.length;
		}, next : function() {
			return this.arr[this.cur++];
		}};
	}
}
HxOverrides.__name__ = true;
class Lambda {
	static exists(it,f) {
		var x = $getIterator(it);
		while(x.hasNext()) if(f(x.next())) {
			return true;
		}
		return false;
	}
	static find(it,f) {
		var v = $getIterator(it);
		while(v.hasNext()) {
			var v1 = v.next();
			if(f(v1)) {
				return v1;
			}
		}
		return null;
	}
}
Lambda.__name__ = true;
Math.__name__ = true;
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( e ) {
			return null;
		}
	}
	static fields(o) {
		var a = [];
		if(o != null) {
			var hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static compare(a,b) {
		if(a == b) {
			return 0;
		} else if(a > b) {
			return 1;
		} else {
			return -1;
		}
	}
}
Reflect.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
}
Std.__name__ = true;
class StringTools {
	static startsWith(s,start) {
		if(s.length >= start.length) {
			return s.lastIndexOf(start,0) == 0;
		} else {
			return false;
		}
	}
	static endsWith(s,end) {
		var elen = end.length;
		var slen = s.length;
		if(slen >= elen) {
			return s.indexOf(end,slen - elen) == slen - elen;
		} else {
			return false;
		}
	}
	static isSpace(s,pos) {
		var c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		var l = s.length;
		var r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		var l = s.length;
		var r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
class Sys {
	static systemName() {
		var _g = process.platform;
		switch(_g) {
		case "darwin":
			return "Mac";
		case "freebsd":
			return "BSD";
		case "linux":
			return "Linux";
		case "win32":
			return "Windows";
		default:
			return _g;
		}
	}
}
Sys.__name__ = true;
var Vscode = require("coc.nvim");
class haxe_Timer {
	constructor(time_ms) {
		var me = this;
		this.id = setInterval(function() {
			me.run();
		},time_ms);
	}
	stop() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	run() {
	}
	static delay(f,time_ms) {
		var t = new haxe_Timer(time_ms);
		t.run = function() {
			t.stop();
			f();
		};
		return t;
	}
}
haxe_Timer.__name__ = true;
class haxe_ds_ArraySort {
	static sort(a,cmp) {
		haxe_ds_ArraySort.rec(a,cmp,0,a.length);
	}
	static rec(a,cmp,from,to) {
		var middle = from + to >> 1;
		if(to - from < 12) {
			if(to <= from) {
				return;
			}
			var _g = from + 1;
			while(_g < to) {
				var j = _g++;
				while(j > from) {
					if(cmp(a[j],a[j - 1]) < 0) {
						haxe_ds_ArraySort.swap(a,j - 1,j);
					} else {
						break;
					}
					--j;
				}
			}
			return;
		}
		haxe_ds_ArraySort.rec(a,cmp,from,middle);
		haxe_ds_ArraySort.rec(a,cmp,middle,to);
		haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
	}
	static doMerge(a,cmp,from,pivot,to,len1,len2) {
		var first_cut;
		var second_cut;
		var len11;
		var len22;
		if(len1 == 0 || len2 == 0) {
			return;
		}
		if(len1 + len2 == 2) {
			if(cmp(a[pivot],a[from]) < 0) {
				haxe_ds_ArraySort.swap(a,pivot,from);
			}
			return;
		}
		if(len1 > len2) {
			len11 = len1 >> 1;
			first_cut = from + len11;
			second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
			len22 = second_cut - pivot;
		} else {
			len22 = len2 >> 1;
			second_cut = pivot + len22;
			first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
			len11 = first_cut - from;
		}
		haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
		var new_mid = first_cut + len22;
		haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
		haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
	}
	static rotate(a,cmp,from,mid,to) {
		if(from == mid || mid == to) {
			return;
		}
		var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
		while(n-- != 0) {
			var val = a[from + n];
			var shift = mid - from;
			var p1 = from + n;
			var p2 = from + n + shift;
			while(p2 != from + n) {
				a[p1] = a[p2];
				p1 = p2;
				if(to - p2 > shift) {
					p2 += shift;
				} else {
					p2 = from + (shift - (to - p2));
				}
			}
			a[p1] = val;
		}
	}
	static gcd(m,n) {
		while(n != 0) {
			var t = m % n;
			m = n;
			n = t;
		}
		return m;
	}
	static upper(a,cmp,from,to,val) {
		var len = to - from;
		var half;
		var mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[val],a[mid]) < 0) {
				len = half;
			} else {
				from = mid + 1;
				len = len - half - 1;
			}
		}
		return from;
	}
	static lower(a,cmp,from,to,val) {
		var len = to - from;
		var half;
		var mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[mid],a[val]) < 0) {
				from = mid + 1;
				len = len - half - 1;
			} else {
				len = half;
			}
		}
		return from;
	}
	static swap(a,i,j) {
		var tmp = a[i];
		a[i] = a[j];
		a[j] = tmp;
	}
}
haxe_ds_ArraySort.__name__ = true;
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
	get(key) {
		return this.h[key];
	}
	remove(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	keys() {
		var a = [];
		for( var key in this.h ) this.h.hasOwnProperty(key) ? a.push(key | 0) : null;
		return HxOverrides.iter(a);
	}
	iterator() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
}
haxe_ds_IntMap.__name__ = true;
class haxe_ds_ObjectMap {
	constructor() {
		this.h = { __keys__ : { }};
	}
	set(key,value) {
		var id = key.__id__ || (key.__id__ = $global.$haxeUID++);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	get(key) {
		return this.h[key.__id__];
	}
	remove(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	keys() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
}
haxe_ds_ObjectMap.__name__ = true;
class haxe_ds_StringMap {
	constructor() {
		this.h = { };
	}
	get(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	setReserved(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	getReserved(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	existsReserved(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	remove(key) {
		if(__map_reserved[key] != null) {
			key = "$" + key;
			if(this.rh == null || !this.rh.hasOwnProperty(key)) {
				return false;
			}
			delete(this.rh[key]);
			return true;
		} else {
			if(!this.h.hasOwnProperty(key)) {
				return false;
			}
			delete(this.h[key]);
			return true;
		}
	}
	keys() {
		return HxOverrides.iter(this.arrayKeys());
	}
	arrayKeys() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
}
haxe_ds_StringMap.__name__ = true;
class haxe_io_Path {
	constructor(path) {
		switch(path) {
		case ".":case "..":
			this.dir = path;
			this.file = "";
			return;
		}
		var c1 = path.lastIndexOf("/");
		var c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			this.dir = HxOverrides.substr(path,0,c2);
			path = HxOverrides.substr(path,c2 + 1,null);
			this.backslash = true;
		} else if(c2 < c1) {
			this.dir = HxOverrides.substr(path,0,c1);
			path = HxOverrides.substr(path,c1 + 1,null);
		} else {
			this.dir = null;
		}
		var cp = path.lastIndexOf(".");
		if(cp != -1) {
			this.ext = HxOverrides.substr(path,cp + 1,null);
			this.file = HxOverrides.substr(path,0,cp);
		} else {
			this.ext = null;
			this.file = path;
		}
	}
	toString() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	static withoutDirectory(path) {
		var s = new haxe_io_Path(path);
		s.dir = null;
		return s.toString();
	}
	static directory(path) {
		var s = new haxe_io_Path(path);
		if(s.dir == null) {
			return "";
		}
		return s.dir;
	}
	static extension(path) {
		var s = new haxe_io_Path(path);
		if(s.ext == null) {
			return "";
		}
		return s.ext;
	}
	static join(paths) {
		var paths1 = paths.filter(function(s) {
			if(s != null) {
				return s != "";
			} else {
				return false;
			}
		});
		if(paths1.length == 0) {
			return "";
		}
		var path = paths1[0];
		var _g = 1;
		var _g1 = paths1.length;
		while(_g < _g1) {
			path = haxe_io_Path.addTrailingSlash(path);
			path += paths1[_g++];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		var slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		var target = [];
		var _g = 0;
		var _g1 = path.split(slash);
		while(_g < _g1.length) {
			var token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		var tmp = target.join(slash);
		var acc_b = "";
		var colon = false;
		var slashes = false;
		var _g2 = 0;
		var _g3 = tmp.length;
		while(_g2 < _g3) {
			var _g21 = tmp.charCodeAt(_g2++);
			switch(_g21) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					var i = _g21;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				var i1 = _g21;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i1);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		var c1 = path.lastIndexOf("/");
		var c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
	static isAbsolute(path) {
		if(StringTools.startsWith(path,"/")) {
			return true;
		}
		if(path.charAt(1) == ":") {
			return true;
		}
		if(StringTools.startsWith(path,"\\\\")) {
			return true;
		}
		return false;
	}
}
haxe_io_Path.__name__ = true;
class haxe_iterators_MapKeyValueIterator {
	constructor(map) {
		this.map = map;
		this.keys = map.keys();
	}
	hasNext() {
		return this.keys.hasNext();
	}
	next() {
		var key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
}
haxe_iterators_MapKeyValueIterator.__name__ = true;
class js__$Boot_HaxeError extends Error {
	constructor(val) {
		super();
		this.val = val;
		if(Error.captureStackTrace) {
			Error.captureStackTrace(this,js__$Boot_HaxeError);
		}
	}
}
js__$Boot_HaxeError.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		var t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(((o) instanceof Array)) {
				if(o.__enum__) {
					if(o.length == 2) {
						return o[0];
					}
					var str = o[0] + "(";
					s += "\t";
					var _g = 2;
					var _g1 = o.length;
					while(_g < _g1) {
						var i = _g++;
						if(i != 2) {
							str += "," + js_Boot.__string_rec(o[i],s);
						} else {
							str += js_Boot.__string_rec(o[i],s);
						}
					}
					return str + ")";
				}
				var l = o.length;
				var i1;
				var str1 = "[";
				s += "\t";
				var _g2 = 0;
				var _g11 = l;
				while(_g2 < _g11) {
					var i2 = _g2++;
					str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
				}
				str1 += "]";
				return str1;
			}
			var tostr;
			try {
				tostr = o.toString;
			} catch( e ) {
				var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				var s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			var str2 = "{\n";
			s += "\t";
			var hasp = o.hasOwnProperty != null;
			var k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str2.length != 2) {
				str2 += ", \n";
			}
			str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str2 += "\n" + s + "}";
			return str2;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
class jsonrpc__$CancellationToken_CancellationTokenImpl {
}
jsonrpc__$CancellationToken_CancellationTokenImpl.__name__ = true;
var jsonrpc_NoData = { __ename__ : true, __constructs__ : [] };
class sys_FileSystem {
	static exists(path) {
		try {
			js_node_Fs.accessSync(path);
			return true;
		} catch( _ ) {
			return false;
		}
	}
	static isDirectory(path) {
		try {
			return js_node_Fs.statSync(path).isDirectory();
		} catch( e ) {
			return false;
		}
	}
	static createDirectory(path) {
		try {
			js_node_Fs.mkdirSync(path);
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "ENOENT") {
				sys_FileSystem.createDirectory(js_node_Path.dirname(path));
				js_node_Fs.mkdirSync(path);
			} else {
				var stat;
				try {
					stat = js_node_Fs.statSync(path);
				} catch( _ ) {
					throw e1;
				}
				if(!stat.isDirectory()) {
					throw e1;
				}
			}
		}
	}
}
sys_FileSystem.__name__ = true;
class sys_io_File {
	static copy(srcPath,dstPath) {
		var src = js_node_Fs.openSync(srcPath,"r");
		var dst = js_node_Fs.openSync(dstPath,"w",js_node_Fs.fstatSync(src).mode);
		var bytesRead;
		var pos = 0;
		while(true) {
			bytesRead = js_node_Fs.readSync(src,sys_io_File.copyBuf,0,65536,pos);
			if(!(bytesRead > 0)) {
				break;
			}
			js_node_Fs.writeSync(dst,sys_io_File.copyBuf,0,bytesRead);
			pos += bytesRead;
		}
		js_node_Fs.closeSync(src);
		js_node_Fs.closeSync(dst);
	}
}
sys_io_File.__name__ = true;
var vscode_CodeActionKind = require("coc.nvim").CodeActionKind;
var vscode_Disposable = require("coc.nvim").Disposable;
var vscode_EventEmitter = require("coc.nvim").EventEmitter;
var vscode_Location = require("coc.nvim").Location;
var vscode_Position = require("coc.nvim").Position;
var vscode_ProcessExecution = require("coc.nvim").ProcessExecution;
var vscode__$ProgressLocation_ProgressLocation_$Impl_$ = require("coc.nvim").ProgressLocation;
var vscode_Range = require("coc.nvim").Range;
var vscode_RelativePattern = require("coc.nvim").RelativePattern;
var vscode__$StatusBarAlignment_StatusBarAlignment_$Impl_$ = require("coc.nvim").StatusBarAlignment;
var vscode_Task = require("coc.nvim").Task;
var vscode_TaskGroup = require("coc.nvim").TaskGroup;
var vscode__$TaskPanelKind_TaskPanelKind_$Impl_$ = require("coc.nvim").TaskPanelKind;
var vscode__$TaskRevealKind_TaskRevealKind_$Impl_$ = require("coc.nvim").TaskRevealKind;
var vscode__$TaskScope_TaskScope_$Impl_$ = require("coc.nvim").TaskScope;
var vscode_ThemeColor = require("coc.nvim").ThemeColor;
var vscode_TreeItem = require("coc.nvim").TreeItem;
var vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$ = require("coc.nvim").TreeItemCollapsibleState;
var vscode_Uri = require("coc.nvim").Uri;
var vscode__$ViewColumn_ViewColumn_$Impl_$ = require("coc.nvim").ViewColumn;
class vshaxe_EvalDebugger {
	constructor(displayArguments,haxeExecutable) {
		this.displayArguments = displayArguments;
		this.haxeExecutable = haxeExecutable;
		Vscode.debug.registerDebugConfigurationProvider("haxe-eval",{ resolveDebugConfiguration : $bind(this,this.resolveDebugConfiguration)});
	}
	resolveDebugConfiguration(folder,config,token) {
		var config1 = config;
		if(config1.type == null) {
			config1.type = "haxe-eval";
			config1.name = "Haxe Interpreter";
			config1.request = "launch";
		}
		if(config1.cwd == null && folder != null) {
			config1.cwd = folder.uri.fsPath;
		}
		if(config1.args == null) {
			config1.args = this.displayArguments.arguments;
		}
		config1.haxeExecutable = this.haxeExecutable.configuration;
		config1.mergeScopes = Vscode.workspace.getConfiguration("haxe.debug").get("mergeScopes",true);
		config1.showGeneratedVariables = Vscode.workspace.getConfiguration("haxe.debug").get("showGeneratedVariables",false);
		return config1;
	}
}
vshaxe_EvalDebugger.__name__ = true;
class vshaxe__$HaxeMemento_HaxeMementoKey_$Impl_$ {
	static _new(key) {
		return "haxe." + key;
	}
}
vshaxe__$HaxeMemento_HaxeMementoKey_$Impl_$.__name__ = true;
class vshaxe_HxmlDiscovery {
	constructor(folder,mementos) {
		var _gthis = this;
		this.folder = folder;
		this.mementos = mementos;
		this.didChangeFilesEmitter = new vscode_EventEmitter();
		this.files = mementos.getDefault(folder,"haxe.hxmlDiscoveryFiles",[]);
		var pattern = new vscode_RelativePattern(folder,"*.hxml");
		this.fileWatcher = Vscode.workspace.createFileSystemWatcher(pattern,false,true,false);
		this.fileWatcher.onDidCreate(function(uri) {
			_gthis.files.push(vshaxe_helper_PathHelper.relativize(uri.fsPath,_gthis.folder.uri.fsPath));
			_gthis.mementos.set(_gthis.folder,"haxe.hxmlDiscoveryFiles",_gthis.files);
			_gthis.didChangeFilesEmitter.fire();
			return;
		});
		this.fileWatcher.onDidDelete(function(uri1) {
			HxOverrides.remove(_gthis.files,vshaxe_helper_PathHelper.relativize(uri1.fsPath,_gthis.folder.uri.fsPath));
			_gthis.mementos.set(_gthis.folder,"haxe.hxmlDiscoveryFiles",_gthis.files);
			_gthis.didChangeFilesEmitter.fire();
			return;
		});
		Vscode.workspace.findFiles(pattern).then(function(files) {
			var foundFiles = [];
			if(files != null) {
				foundFiles = files.map(function(uri2) {
					return vshaxe_helper_PathHelper.relativize(uri2.fsPath,_gthis.folder.uri.fsPath);
				}).filter(function(path) {
					return haxe_io_Path.withoutDirectory(path) != "extraParams.hxml";
				});
			}
			if(!vshaxe_helper_ArrayHelper.equals(_gthis.files,foundFiles)) {
				_gthis.files = foundFiles;
				_gthis.mementos.set(_gthis.folder,"haxe.hxmlDiscoveryFiles",_gthis.files);
				_gthis.didChangeFilesEmitter.fire();
			}
			return;
		});
	}
	dispose() {
		this.fileWatcher.dispose();
		this.didChangeFilesEmitter.dispose();
	}
}
vshaxe_HxmlDiscovery.__name__ = true;
class vshaxe_Main {
	constructor(context) {
		new vshaxe_commands_InitProject(context);
		var wsFolder = Vscode.workspace.workspaceFolders == null ? null : Vscode.workspace.workspaceFolders[0];
		if(wsFolder == null) {
			return;
		}
		Vscode.commands.executeCommand("setContext","vshaxeActivated",true);
		var wsMementos = new vshaxe_WorkspaceMementos(context.workspaceState);
		var hxmlDiscovery = new vshaxe_HxmlDiscovery(wsFolder,wsMementos);
		context.subscriptions.push(hxmlDiscovery);
		var displayArguments = new vshaxe_display_DisplayArguments(wsFolder,wsMementos);
		context.subscriptions.push(displayArguments);
		var haxeExecutable = new vshaxe_helper_HaxeExecutable(wsFolder);
		context.subscriptions.push(haxeExecutable);
		var problemMatchers = ["$haxe-absolute","$haxe","$haxe-error","$haxe-trace"];
		this.api = { haxeExecutable : haxeExecutable, enableCompilationServer : true, problemMatchers : problemMatchers.slice(), taskPresentation : { }, registerDisplayArgumentsProvider : $bind(displayArguments,displayArguments.registerProvider), parseHxmlToArguments : vshaxe_helper_HxmlParser.parseToArgs};
		var server = new vshaxe_server_LanguageServer(wsFolder,context,haxeExecutable,displayArguments,this.api);
		context.subscriptions.push(server);
		new vshaxe_helper_HaxeCodeLensProvider();
		new vshaxe_view_HaxeServerViewContainer(context,server);
		new vshaxe_view_dependencies_DependencyTreeView(context,displayArguments,haxeExecutable);
		new vshaxe_EvalDebugger(displayArguments,haxeExecutable);
		new vshaxe_display_DisplayArgumentsSelector(context,displayArguments);
		var haxeDisplayArgumentsProvider = new vshaxe_display_HaxeDisplayArgumentsProvider(context,displayArguments,hxmlDiscovery);
		new vshaxe_commands_Commands(context,server,haxeDisplayArgumentsProvider);
		var taskConfiguration = new vshaxe_tasks_TaskConfiguration(haxeExecutable,problemMatchers,server,this.api);
		new vshaxe_tasks_HxmlTaskProvider(taskConfiguration,hxmlDiscovery);
		new vshaxe_tasks_HaxeTaskProvider(taskConfiguration,displayArguments,haxeDisplayArgumentsProvider);
		if(displayArguments.arguments == null) {
			var serverStarted = false;
			var disposable = displayArguments._onDidChangeArguments.event(function($arguments) {
				disposable.dispose();
				server.start();
				serverStarted = true;
				return serverStarted;
			});
			haxe_Timer.delay(function() {
				if(!serverStarted) {
					disposable.dispose();
					server.start();
				}
				return;
			},5000);
		} else {
			server.start();
		}
	}
	static main(context) {
		return new vshaxe_Main(context).api;
	}
}
$hx_exports["activate"] = vshaxe_Main.main;
vshaxe_Main.__name__ = true;
class vshaxe_WorkspaceMementos {
	constructor(storage) {
		this.storage = storage;
		this.maybeMigrate();
	}
	getDefault(folder,key,defaultValue) {
		var value = this.get(folder,key);
		if(value == null) {
			return defaultValue;
		} else {
			return value;
		}
	}
	get(folder,key) {
		var collection = this.storage.get(key);
		if(collection == null) {
			return null;
		}
		return collection[folder.uri.toString()];
	}
	set(folder,key,value) {
		var collection = this.storage.get(key);
		if(collection == null) {
			collection = { };
		}
		collection[folder.uri.toString()] = value;
		return this.storage.update(key,collection);
	}
	maybeMigrate() {
		var _gthis = this;
		if(this.storage.get("haxe.mementoVersion") == null) {
			_gthis.storage.update("haxe.displayArgumentsProviderName",undefined);
			_gthis.storage.update(vshaxe_display_HaxeDisplayArgumentsProvider.ConfigurationIndexKey,undefined);
			_gthis.storage.update("haxe.hxmlDiscoveryFiles",undefined);
			this.storage.update("haxe.mementoVersion",1);
		}
	}
}
vshaxe_WorkspaceMementos.__name__ = true;
class vshaxe_commands_Commands {
	constructor(context,server,haxeDisplayArgumentsProvider) {
		this.context = context;
		this.server = server;
		this.haxeDisplayArgumentsProvider = haxeDisplayArgumentsProvider;
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "restartLanguageServer",$bind(server,server.restart));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "showReferences",$bind(this,this.showReferences));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "runGlobalDiagnostics",$bind(server,server.runGlobalDiagnostics));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "toggleCodeLens",$bind(this,this.toggleCodeLens));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "debugSelectedConfiguration",$bind(this,this.debugSelectedConfiguration));
	}
	showReferences(uri,position,locations) {
		var locations1 = locations.map(function(location) {
			var locations2 = vscode_Uri.parse(location.uri);
			var position1 = location.range.start;
			var locations3 = new vscode_Position(position1.line,position1.character);
			var position2 = location.range.end;
			return new vscode_Location(locations2,new vscode_Range(locations3,new vscode_Position(position2.line,position2.character)));
		});
		Vscode.commands.executeCommand("editor.action.showReferences",vscode_Uri.parse(uri),new vscode_Position(position.line,position.character),locations1).then(function(s) {
			console.log("src/vshaxe/commands/Commands.hx:35:",s);
			return;
		},function(s1) {
			console.log("src/vshaxe/commands/Commands.hx:35:","err: " + s1);
			return;
		});
	}
	toggleCodeLens() {
		var config = Vscode.workspace.getConfiguration("haxe");
		var info = config.inspect("enableCodeLens");
		if(info == null) {
			return;
		}
		var value = this.getCurrentConfigValue(info,config);
		if(value == null) {
			value = false;
		}
		config.update("enableCodeLens",!value,info.workspaceValue == null);
	}
	debugSelectedConfiguration() {
		if(this.haxeDisplayArgumentsProvider.provideArguments == null) {
			Vscode.window.showErrorMessage("The built-in completion provider is not active, so there is no configuration to be debugged.");
			return;
		}
		var label = this.haxeDisplayArgumentsProvider.getCurrentLabel();
		if(label == null) {
			Vscode.window.showErrorMessage("There is no configuration selected.");
			return;
		}
		var folder = null;
		if(Vscode.workspace.workspaceFolders != null) {
			folder = Vscode.workspace.workspaceFolders[0];
		}
		Vscode.debug.startDebugging(folder,label).then(function(_) {
			return { };
		},function(error) {
			return Vscode.window.showErrorMessage(Std.string(error));
		});
	}
	getCurrentConfigValue(info,config) {
		var value = info.workspaceValue;
		if(value == null) {
			value = info.globalValue;
		}
		if(value == null) {
			value = info.defaultValue;
		}
		return value;
	}
}
vshaxe_commands_Commands.__name__ = true;
class vshaxe_commands_InitProject {
	constructor(context) {
		this.context = context;
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "initProject",$bind(this,this.initProject));
	}
	initProject() {
		var _gthis = this;
		var _g = Vscode.workspace.workspaceFolders;
		if(_g == null) {
			Vscode.window.showOpenDialog({ canSelectFolders : true, canSelectFiles : false}).then(function(folders) {
				if(folders != null && folders.length > 0) {
					_gthis.setupFolder(folders[0].fsPath);
					Vscode.commands.executeCommand("vscode.openFolder",folders[0]);
				}
				return;
			});
		} else {
			switch(_g.length) {
			case 0:
				Vscode.window.showOpenDialog({ canSelectFolders : true, canSelectFiles : false}).then(function(folders1) {
					if(folders1 != null && folders1.length > 0) {
						_gthis.setupFolder(folders1[0].fsPath);
						Vscode.commands.executeCommand("vscode.openFolder",folders1[0]);
					}
					return;
				});
				break;
			case 1:
				this.setupFolder(_g[0].uri.fsPath);
				break;
			default:
				Vscode.window.showWorkspaceFolderPick({ placeHolder : "Select a folder to set up a Haxe project into..."}).then(function(folder) {
					if(folder == null) {
						return;
					}
					_gthis.setupFolder(folder.uri.fsPath);
				});
			}
		}
	}
	setupFolder(fsPath) {
		if(Lambda.exists(js_node_Fs.readdirSync(fsPath),function(f) {
			return !StringTools.startsWith(f,".");
		})) {
			Vscode.window.showErrorMessage("To set up sample Haxe project, the folder must be empty");
			return;
		}
		this.copyRec(this.context.asAbsolutePath("./scaffold/project"),fsPath);
		Vscode.window.setStatusBarMessage("Haxe project scaffolded",2000);
	}
	copyRec(from,to) {
		var loop = null;
		loop = function(src,dst) {
			var fromPath = from + src;
			var toPath = to + dst;
			if(sys_FileSystem.isDirectory(fromPath)) {
				sys_FileSystem.createDirectory(toPath);
				var _g = 0;
				var _g1 = js_node_Fs.readdirSync(fromPath);
				while(_g < _g1.length) {
					var file = _g1[_g];
					++_g;
					loop(src + "/" + file,dst + "/" + file);
				}
			} else {
				sys_io_File.copy(fromPath,toPath);
			}
		};
		loop("","");
	}
}
vshaxe_commands_InitProject.__name__ = true;
class vshaxe_display_DisplayArguments {
	constructor(folder,mementos) {
		this._onDidChangeCurrentProvider = new vscode_EventEmitter();
		this._onDidChangeArguments = new vscode_EventEmitter();
		this.providers = new haxe_ds_StringMap();
		this.folder = folder;
		this.mementos = mementos;
	}
	dispose() {
		this._onDidChangeArguments.dispose();
		this._onDidChangeCurrentProvider.dispose();
	}
	registerProvider(name,provider) {
		var _gthis = this;
		var _this = this.providers;
		if(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name)) {
			throw new Error("Display arguments provider `" + name + "` is already registered.");
		}
		var _this1 = this.providers;
		if(__map_reserved[name] != null) {
			_this1.setReserved(name,provider);
		} else {
			_this1.h[name] = provider;
		}
		var savedProvider = this.mementos.get(this.folder,"haxe.displayArgumentsProviderName");
		if(this.currentProvider == null || savedProvider == null || savedProvider == name) {
			this.setCurrentProvider(name,false);
		}
		return new vscode_Disposable(function() {
			_gthis.providers.remove(name);
			if(name == _gthis.currentProvider) {
				_gthis.setCurrentProvider(null,false);
			}
		});
	}
	setCurrentProvider(name,persist) {
		if(this.currentProvider != null) {
			var key = this.currentProvider;
			var _this = this.providers;
			var provider = __map_reserved[key] != null ? _this.getReserved(key) : _this.h[key];
			if(provider != null) {
				provider.deactivate();
			}
		}
		this.currentProvider = name;
		Vscode.commands.executeCommand("setContext","haxeCompletionProvider",name);
		if(name != null) {
			var _this1 = this.providers;
			var provider1 = __map_reserved[name] != null ? _this1.getReserved(name) : _this1.h[name];
			if(provider1 != null) {
				provider1.activate($bind(this,this.provideArguments));
			}
		}
		if(persist) {
			this.mementos.set(this.folder,"haxe.displayArgumentsProviderName",name);
		}
		this._onDidChangeCurrentProvider.fire(this.currentProvider);
	}
	provideArguments(newArguments) {
		if(!vshaxe_helper_ArrayHelper.equals(newArguments,this.arguments)) {
			this.arguments = newArguments;
			this._onDidChangeArguments.fire(newArguments);
		}
	}
}
vshaxe_display_DisplayArguments.__name__ = true;
class vshaxe_display_DisplayArgumentsSelector {
	constructor(context,displayArguments) {
		var _gthis = this;
		this.displayArguments = displayArguments;
		this.statusBarItem = Vscode.window.createStatusBarItem(vscode__$StatusBarAlignment_StatusBarAlignment_$Impl_$.Left,11);
		this.statusBarItem.tooltip = "Select Haxe Completion Provider";
		this.statusBarItem.command = "haxe." + "selectDisplayArgumentsProvider";
		context.subscriptions.push(this.statusBarItem);
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "selectDisplayArgumentsProvider",$bind(this,this.selectProvider));
		displayArguments._onDidChangeCurrentProvider.event(function(_) {
			_gthis.updateStatusBarItem();
			return;
		});
		this.updateStatusBarItem();
	}
	selectProvider() {
		var _gthis = this;
		var _g = [];
		var _g1 = new haxe_iterators_MapKeyValueIterator(this.displayArguments.providers);
		while(_g1.hasNext()) {
			var _g2 = _g1.next();
			_g.push({ label : _g2.key, description : _g2.value.description});
		}
		if(_g.length == 0) {
			Vscode.window.showErrorMessage("No Haxe completion providers registered.");
			return;
		}
		vshaxe_helper_ArrayHelper.moveToStart(_g,function(item) {
			return item.label == _gthis.displayArguments.currentProvider;
		});
		Vscode.window.showQuickPick(_g,{ placeHolder : "Select Haxe Completion Provider"}).then(function(item1) {
			if(item1 != null) {
				_gthis.displayArguments.setCurrentProvider(item1.label,true);
			}
			return;
		});
	}
	updateStatusBarItem() {
		if(this.displayArguments.currentProvider == null) {
			this.statusBarItem.hide();
			return;
		}
		var label = this.displayArguments.currentProvider;
		var color = null;
		var name = this.displayArguments.currentProvider;
		var _this = this.displayArguments.providers;
		if(!(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name))) {
			label += " (not available)";
			color = vshaxe_display_DisplayArgumentsSelector.statusBarWarningThemeColor;
		}
		this.statusBarItem.color = color;
		this.statusBarItem.text = "$(gear) " + label;
		this.statusBarItem.show();
	}
}
vshaxe_display_DisplayArgumentsSelector.__name__ = true;
class vshaxe_display_HaxeDisplayArgumentsProvider {
	constructor(context,displayArguments,hxmlDiscovery) {
		this.description = "Project using haxe.displayConfigurations or HXML files (built-in)";
		this.configurations = [];
		var _gthis = this;
		this.context = context;
		this.displayArguments = displayArguments;
		this.hxmlDiscovery = hxmlDiscovery;
		this.statusBarItem = Vscode.window.createStatusBarItem(vscode__$StatusBarAlignment_StatusBarAlignment_$Impl_$.Left,10);
		this.statusBarItem.tooltip = "Select Haxe Configuration";
		this.statusBarItem.command = "haxe." + "selectDisplayConfiguration";
		context.subscriptions.push(this.statusBarItem);
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "selectDisplayConfiguration",$bind(this,this.selectConfiguration));
		context.subscriptions.push(Vscode.workspace.onDidChangeConfiguration(function(_) {
			_gthis.refresh();
			return;
		}));
		hxmlDiscovery.didChangeFilesEmitter.event(function(_1) {
			_gthis.refresh();
			return;
		});
		this.refresh();
	}
	updateConfigurations() {
		var configs = Vscode.workspace.getConfiguration("haxe").get("displayConfigurations",[]);
		if(configs == null) {
			configs = [];
		}
		this.configurations = [];
		var _g = 0;
		var _g1 = configs.length;
		while(_g < _g1) {
			var i = _g++;
			var config = configs[i];
			var args;
			var label = null;
			if(((config) instanceof Array) && config.__enum__ == null) {
				args = config;
			} else {
				var config1 = config;
				args = config1.args;
				label = config1.label;
			}
			this.configurations.push({ kind : vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Configured(i,label), args : args});
		}
		var _g2 = 0;
		var _g3 = this.hxmlDiscovery.files;
		while(_g2 < _g3.length) {
			var hxmlFile = _g3[_g2];
			++_g2;
			var hxmlConfig = [[hxmlFile]];
			if(!Lambda.exists(configs,(function(hxmlConfig1) {
				return function(config2) {
					return vshaxe_helper_ArrayHelper.equals(config2,hxmlConfig1[0]);
				};
			})(hxmlConfig))) {
				this.configurations.push({ kind : vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Discovered(hxmlFile), args : hxmlConfig[0]});
			}
		}
	}
	activate(provideArguments) {
		this.provideArguments = provideArguments;
		this.setCurrent(this.getCurrent());
	}
	deactivate() {
		this.provideArguments = null;
		this.updateStatusBarItem(null);
	}
	selectConfiguration() {
		var _gthis = this;
		if(this.configurations.length == 0) {
			Vscode.window.showErrorMessage("No Haxe configurations are available. Please provide the haxe.displayConfigurations setting.",{ title : "Edit settings"}).then(function(button) {
				if(button == null) {
					return;
				}
				Vscode.workspace.getConfiguration("haxe").update("displayConfigurations",[],false).then(function(_) {
					if(Vscode.workspace.workspaceFolders == null) {
						return;
					}
					Vscode.workspace.openTextDocument(Vscode.workspace.workspaceFolders[0].uri.fsPath + "/.vscode/settings.json").then(function(document) {
						return Vscode.window.showTextDocument(document);
					});
				});
			});
			return;
		}
		var items = [];
		var _g = 0;
		var _g1 = this.configurations;
		while(_g < _g1.length) {
			var configuration = _g1[_g];
			++_g;
			var description = configuration.kind[1] == 1;
			items.push({ label : this.getConfigurationLabel(configuration), description : description ? "auto-discovered" : "from settings.json", config : configuration});
		}
		var current = this.getCurrent();
		if(current != null) {
			vshaxe_helper_ArrayHelper.moveToStart(items,function(item) {
				return item.config == current;
			});
		}
		Vscode.window.showQuickPick(items,{ matchOnDescription : true, placeHolder : "Select Haxe Configuration"}).then(function(choice) {
			if(choice == null || choice.config == current) {
				return;
			}
			var this1 = _gthis.context.workspaceState;
			var value;
			var _g2 = choice.config.kind;
			switch(_g2[1]) {
			case 0:
				value = _g2[2];
				break;
			case 1:
				value = _g2[2];
				break;
			}
			this1.update(vshaxe_display_HaxeDisplayArgumentsProvider.ConfigurationIndexKey,value);
			_gthis.setCurrent(choice.config);
		});
	}
	getCurrentLabel() {
		var current = this.getCurrent();
		if(current == null) {
			return null;
		}
		return this.getConfigurationLabel(current);
	}
	getConfigurationLabel(configuration) {
		var _g = configuration.kind;
		switch(_g[1]) {
		case 0:
			var _g2 = _g[3];
			if(_g2 != null) {
				return _g2;
			} else {
				return configuration.args.join(" ");
			}
			break;
		case 1:
			return _g[2];
		}
	}
	getCurrent() {
		var selection = this.context.workspaceState.get(vshaxe_display_HaxeDisplayArgumentsProvider.ConfigurationIndexKey,null);
		var _g = 0;
		var _g1 = this.configurations;
		while(_g < _g1.length) {
			var conf = _g1[_g];
			++_g;
			var _g2 = conf.kind;
			switch(_g2[1]) {
			case 0:
				if(_g2[2] == selection) {
					return conf;
				}
				break;
			case 1:
				if(_g2[2] == selection) {
					return conf;
				}
				break;
			default:
			}
		}
		return this.configurations[0];
	}
	setCurrent(config) {
		this.updateStatusBarItem(config);
		if(this.provideArguments != null) {
			this.provideArguments(config == null ? [] : config.args);
		}
	}
	refresh() {
		this.updateConfigurations();
		this.updateDisplayArgumentsProviderRegistration();
		this.setCurrent(this.getCurrent());
	}
	updateDisplayArgumentsProviderRegistration() {
		var isActive = this.configurations.length > 0;
		if(isActive && this.providerDisposable == null) {
			this.providerDisposable = this.displayArguments.registerProvider("Haxe",this);
		} else if(!isActive && this.providerDisposable != null) {
			this.providerDisposable.dispose();
			this.providerDisposable = null;
		}
	}
	updateStatusBarItem(config) {
		if(this.provideArguments != null && config != null) {
			var _g = config.kind;
			var label = _g[1] == 0 ? _g[3] : null;
			if(label == null) {
				label = config.args.join(" ");
				if(label.length > 50) {
					label = StringTools.rtrim(HxOverrides.substr(label,0,47)) + "...";
				}
			}
			this.statusBarItem.text = label;
			this.statusBarItem.show();
			return;
		}
		this.statusBarItem.hide();
	}
}
vshaxe_display_HaxeDisplayArgumentsProvider.__name__ = true;
var vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind = { __ename__ : true, __constructs__ : ["Configured","Discovered"] };
vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Configured = function(index,label) { var $x = ["Configured",0,index,label]; $x.__enum__ = vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind; $x.toString = $estr; return $x; }
vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Discovered = function(id) { var $x = ["Discovered",1,id]; $x.__enum__ = vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind; $x.toString = $estr; return $x; }
class vshaxe_helper_ArrayHelper {
	static equals(a1,a2) {
		if(a1 == null && a2 == null) {
			return true;
		}
		if(a1 == null && a2 != null) {
			return false;
		}
		if(a1 != null && a2 == null) {
			return false;
		}
		if(a1.length != a2.length) {
			return false;
		}
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			if(a1[i] != a2[i]) {
				return false;
			}
		}
		return true;
	}
	static moveToStart(array,f) {
		var element = Lambda.find(array,f);
		if(element != null) {
			HxOverrides.remove(array,element);
			array.unshift(element);
		}
	}
}
vshaxe_helper_ArrayHelper.__name__ = true;
class vshaxe_helper_ContextHelper {
	static registerHaxeCommand(context,command,callback) {
		context.subscriptions.push(Vscode.commands.registerCommand(command,callback));
	}
}
vshaxe_helper_ContextHelper.__name__ = true;
class vshaxe_helper_HaxeCodeLensProvider {
	constructor() {
		this._onDidChangeCodeLenses = new vscode_EventEmitter();
		this.onDidChangeCodeLenses = this._onDidChangeCodeLenses.event;
		this.enableCodeLens = this.getEnableCodeLens();
		Vscode.languages.registerCodeLensProvider("haxe",this);
		Vscode.workspace.onDidChangeConfiguration($bind(this,this.onDidChangeConfiguration));
	}
	getEnableCodeLens() {
		return Vscode.workspace.getConfiguration("haxe").get("enableCodeLens",false);
	}
	onDidChangeConfiguration(_) {
		var enableCodeLens = this.getEnableCodeLens();
		if(enableCodeLens != this.enableCodeLens) {
			this._onDidChangeCodeLenses.fire();
			this.enableCodeLens = enableCodeLens;
		}
	}
	provideCodeLenses(document,token) {
		return [];
	}
	resolveCodeLens(codeLens,token) {
		return codeLens;
	}
}
vshaxe_helper_HaxeCodeLensProvider.__name__ = true;
class vshaxe_helper_HaxeExecutable {
	constructor(folder) {
		this.folder = folder;
		this._onDidChangeConfiguration = new vscode_EventEmitter();
		var input = Vscode.workspace.getConfiguration("haxe",this.folder.uri).get("executable","haxe");
		var executable = "haxe";
		var env = { };
		var merge = function(conf) {
			if(typeof(conf) == "string") {
				executable = conf;
			} else {
				var conf1 = conf;
				if(conf1.path != null) {
					executable = conf1.path;
				}
				if(conf1.env != null) {
					env = conf1.env;
				}
			}
		};
		merge(input);
		var systemConfig = Reflect.field(input,vshaxe_helper_HaxeExecutable.SYSTEM_KEY);
		if(systemConfig != null) {
			merge(systemConfig);
		}
		var isCommand = false;
		if(!haxe_io_Path.isAbsolute(executable)) {
			var absolutePath = vshaxe_helper_PathHelper.absolutize(executable,this.folder.uri.fsPath);
			if(sys_FileSystem.exists(absolutePath) && !sys_FileSystem.isDirectory(absolutePath)) {
				executable = absolutePath;
			} else {
				isCommand = true;
				if(Sys.systemName() == "Windows" && haxe_io_Path.extension(executable) == "") {
					executable += ".exe";
				}
			}
		}
		this.rawConfig = input;
		this.configuration = { executable : executable, isCommand : isCommand, env : env};
		this.changeConfigurationListener = Vscode.workspace.onDidChangeConfiguration($bind(this,this.onWorkspaceConfigurationChanged));
	}
	get_onDidChangeConfiguration() {
		return this._onDidChangeConfiguration.event;
	}
	dispose() {
		this.changeConfigurationListener.dispose();
	}
	isConfigured() {
		var executableSetting = Vscode.workspace.getConfiguration("haxe",this.folder.uri).inspect("executable");
		if(executableSetting == null) {
			return false;
		}
		if(!(executableSetting.globalValue != null || executableSetting.workspaceValue != null)) {
			return executableSetting.workspaceFolderValue != null;
		} else {
			return true;
		}
	}
	onWorkspaceConfigurationChanged(change) {
		if(change.affectsConfiguration("haxe.executable",this.folder.uri)) {
			var oldConfig = this.rawConfig;
			this.updateConfig();
			if(!vshaxe_helper_HaxeExecutable.isSame(oldConfig,this.rawConfig)) {
				this._onDidChangeConfiguration.fire(this.configuration);
			}
		}
	}
	updateConfig() {
		var input = Vscode.workspace.getConfiguration("haxe",this.folder.uri).get("executable","haxe");
		var executable = "haxe";
		var env = { };
		var merge = function(conf) {
			if(typeof(conf) == "string") {
				executable = conf;
			} else {
				var conf1 = conf;
				if(conf1.path != null) {
					executable = conf1.path;
				}
				if(conf1.env != null) {
					env = conf1.env;
				}
			}
		};
		merge(input);
		var systemConfig = Reflect.field(input,vshaxe_helper_HaxeExecutable.SYSTEM_KEY);
		if(systemConfig != null) {
			merge(systemConfig);
		}
		var isCommand = false;
		if(!haxe_io_Path.isAbsolute(executable)) {
			var absolutePath = vshaxe_helper_PathHelper.absolutize(executable,this.folder.uri.fsPath);
			if(sys_FileSystem.exists(absolutePath) && !sys_FileSystem.isDirectory(absolutePath)) {
				executable = absolutePath;
			} else {
				isCommand = true;
				if(Sys.systemName() == "Windows" && haxe_io_Path.extension(executable) == "") {
					executable += ".exe";
				}
			}
		}
		this.rawConfig = input;
		this.configuration = { executable : executable, isCommand : isCommand, env : env};
	}
	static isSame(oldConfig,newConfig) {
		if(typeof(oldConfig) == "string" || typeof(newConfig) == "string") {
			if(oldConfig != newConfig) {
				return false;
			}
		}
		if(oldConfig.path != newConfig.path) {
			return false;
		}
		var oldKeys = Reflect.fields(oldConfig.env);
		var newKeys = Reflect.fields(newConfig.env);
		if(oldKeys.length != newKeys.length) {
			return false;
		}
		var _g = 0;
		while(_g < newKeys.length) {
			var key = newKeys[_g];
			++_g;
			if(oldConfig.env[key] != newConfig.env[key]) {
				return false;
			}
			HxOverrides.remove(oldKeys,key);
		}
		if(oldKeys.length > 0) {
			return false;
		}
		return true;
	}
}
vshaxe_helper_HaxeExecutable.__name__ = true;
var vshaxe_helper_HxmlLine = { __ename__ : true, __constructs__ : ["Comment","Simple","Param"] };
vshaxe_helper_HxmlLine.Comment = function(comment) { var $x = ["Comment",0,comment]; $x.__enum__ = vshaxe_helper_HxmlLine; $x.toString = $estr; return $x; }
vshaxe_helper_HxmlLine.Simple = function(name) { var $x = ["Simple",1,name]; $x.__enum__ = vshaxe_helper_HxmlLine; $x.toString = $estr; return $x; }
vshaxe_helper_HxmlLine.Param = function(name,value) { var $x = ["Param",2,name,value]; $x.__enum__ = vshaxe_helper_HxmlLine; $x.toString = $estr; return $x; }
class vshaxe_helper_HxmlParser {
	static unquote(s) {
		var len = s.length;
		if(len > 0 && s.charCodeAt(0) == 34 && s.charCodeAt(len - 1) == 34) {
			return s.substring(1,len - 1);
		} else {
			return s;
		}
	}
	static parseFile(src) {
		var result = [];
		var srcLines = new EReg("[\n\r]+","g").split(src);
		var _g = 0;
		while(_g < srcLines.length) {
			var line = srcLines[_g];
			++_g;
			line = vshaxe_helper_HxmlParser.unquote(StringTools.trim(line));
			if(line.length == 0) {
				continue;
			}
			if(StringTools.startsWith(line,"#")) {
				result.push(vshaxe_helper_HxmlLine.Comment(StringTools.ltrim(HxOverrides.substr(line,1,null))));
			} else if(StringTools.startsWith(line,"-")) {
				var idx = line.indexOf(" ");
				if(idx == -1) {
					result.push(vshaxe_helper_HxmlLine.Simple(line));
				} else {
					result.push(vshaxe_helper_HxmlLine.Param(HxOverrides.substr(line,0,idx),vshaxe_helper_HxmlParser.unquote(StringTools.ltrim(HxOverrides.substr(line,idx,null)))));
				}
			} else {
				result.push(vshaxe_helper_HxmlLine.Simple(line));
			}
		}
		return result;
	}
	static parseToArgs(src) {
		var result = [];
		var _g = 0;
		var _g1 = vshaxe_helper_HxmlParser.parseFile(src);
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			switch(line[1]) {
			case 0:
				break;
			case 1:
				result.push(line[2]);
				break;
			case 2:
				result.push(line[2]);
				result.push(line[3]);
				break;
			}
		}
		return result;
	}
	static parseArray(args) {
		var result = [];
		var flag = null;
		var _g = 0;
		while(_g < args.length) {
			var arg = args[_g];
			++_g;
			if(StringTools.startsWith(arg,"-")) {
				if(flag != null) {
					result.push(vshaxe_helper_HxmlLine.Simple(flag));
					flag = null;
				}
				flag = arg;
			} else if(flag != null) {
				result.push(vshaxe_helper_HxmlLine.Param(flag,arg));
				flag = null;
			} else {
				result.push(vshaxe_helper_HxmlLine.Simple(arg));
			}
		}
		if(flag != null) {
			result.push(vshaxe_helper_HxmlLine.Simple(flag));
		}
		return result;
	}
}
vshaxe_helper_HxmlParser.__name__ = true;
class vshaxe_helper_PathHelper {
	static absolutize(path,cwd) {
		return haxe_io_Path.normalize(haxe_io_Path.isAbsolute(path) ? path : haxe_io_Path.join([cwd,path]));
	}
	static relativize(path,cwd) {
		path = haxe_io_Path.normalize(path);
		cwd = haxe_io_Path.normalize(cwd) + "/";
		var segments = path.split(cwd);
		segments.shift();
		return segments.join(cwd);
	}
	static containsFile(directory,file) {
		directory = haxe_io_Path.normalize(directory) + "/";
		var fileDirectory = haxe_io_Path.normalize(haxe_io_Path.directory(file)) + "/";
		if(Sys.systemName() == "Windows") {
			directory = directory.toLowerCase();
			fileDirectory = fileDirectory.toLowerCase();
		}
		return StringTools.startsWith(fileDirectory,directory);
	}
	static areEqual(path1,path2) {
		if(Sys.systemName() == "Windows") {
			path1 = path1.toLowerCase();
			path2 = path2.toLowerCase();
		}
		return haxe_io_Path.normalize(path1) == haxe_io_Path.normalize(path2);
	}
	static capitalizeDriveLetter(path) {
		if(Sys.systemName() == "Windows" && haxe_io_Path.isAbsolute(path)) {
			path = path.charAt(0).toUpperCase() + HxOverrides.substr(path,1,null);
		}
		return path;
	}
}
vshaxe_helper_PathHelper.__name__ = true;
var vshaxe_server_LanguageClient = require("vscode-languageclient").LanguageClient;
class vshaxe_server_LanguageServer {
	constructor(folder,context,haxeExecutable,displayArguments,api) {
		this._onDidChangeRequestQueue = new vscode_EventEmitter();
		this._onDidRunHaxeMethod = new vscode_EventEmitter();
		this.progresses = new haxe_ds_IntMap();
		var _gthis = this;
		this.folder = folder;
		this.context = context;
		this.displayArguments = displayArguments;
		this.haxeExecutable = haxeExecutable;
		this.api = api;
		this.serverModulePath = context.asAbsolutePath("./server_wrapper.js");
		this.hxFileWatcher = Vscode.workspace.createFileSystemWatcher(new vscode_RelativePattern(folder,"**/*.hx"),false,true,false);
		var path = this.haxeExecutable.configuration.executable;
		var env = this.haxeExecutable.configuration.env;
		var haxeConfig = Vscode.workspace.getConfiguration("haxe");
		var $arguments = haxeConfig.get("displayServer.arguments",[]);
		var print = haxeConfig.get("displayServer.print",{ completion : false, reusing : false});
		if(!this.haxeExecutable.isConfigured()) {
			var displayServerConfig = haxeConfig.get("displayServer");
			var merge = function(conf) {
				if(conf.haxePath != null) {
					path = conf.haxePath;
				}
				if(conf.env != null) {
					env = conf.env;
				}
			};
			if(displayServerConfig != null) {
				merge(displayServerConfig);
				var systemConfig = Reflect.field(displayServerConfig,vshaxe_helper_HaxeExecutable.SYSTEM_KEY);
				if(systemConfig != null) {
					merge(systemConfig);
				}
			}
		}
		this.displayServerConfig = { path : path, env : env, 'arguments' : $arguments, print : print};
		this.displayServerConfigSerialized = JSON.stringify(this.displayServerConfig);
		this.restartDisposables = [];
		this.disposables = [this.hxFileWatcher,Vscode.workspace.onDidChangeConfiguration(function(_) {
			_gthis.refreshDisplayServerConfig();
			return;
		}),(haxeExecutable.get_onDidChangeConfiguration())(function(_1) {
			_gthis.refreshDisplayServerConfig();
			return;
		}),Vscode.window.onDidChangeActiveTextEditor($bind(this,this.onDidChangeActiveTextEditor))];
	}
	dispose() {
		var _g = 0;
		var _g1 = this.restartDisposables;
		while(_g < _g1.length) _g1[_g++].dispose();
		var _g2 = 0;
		var _g3 = this.disposables;
		while(_g2 < _g3.length) _g3[_g2++].dispose();
	}
	sendNotification(method,params) {
		if(this.client != null) {
			if(params == null) {
				this.client.sendNotification(method);
			} else {
				this.client.sendNotification(method,params);
			}
		}
	}
	sendRequest(method,params) {
		if(this.client != null) {
			return this.client.sendRequest(method,params);
		} else {
			return Promise.reject("client not initialized");
		}
	}
	onNotification(method,handler) {
		if(this.client != null) {
			this.client.onNotification(method,handler);
		}
	}
	refreshDisplayServerConfig() {
		if(this.prepareDisplayServerConfig()) {
			this.sendNotification("haxe/didChangeDisplayServerConfig",this.displayServerConfig);
		}
	}
	onDidChangeActiveTextEditor(editor) {
		if(editor != null && editor.document.languageId == "haxe") {
			this.sendNotification("haxe/didChangeActiveTextEditor",{ uri : editor.document.uri.toString()});
		}
	}
	start() {
		var _gthis = this;
		var clientOptions = { documentSelector : [{ scheme : "file", language : "haxe"},{ scheme : "untitled", language : "haxe"}], synchronize : { configurationSection : "haxe", fileEvents : this.hxFileWatcher}, initializationOptions : { displayArguments : this.displayArguments.arguments, displayServerConfig : this.displayServerConfig, sendMethodResults : true}, revealOutputChannelOn : 4, workspaceFolder : this.folder, middleware : { provideCodeActions : function(document,range,context,token,next) {
			var result = next(document,range,context,token);
			var handle = function(result1) {
				var _g = 0;
				while(_g < result1.length) {
					var action = result1[_g];
					++_g;
					if(action.kind == vscode_CodeActionKind.QuickFix) {
						action.isPreferred = true;
						break;
					}
				}
			};
			return new Promise(function(resolve,reject) {
				if(((result) instanceof Array) && result.__enum__ == null) {
					handle(result);
					resolve(result);
				} else {
					result.then(function(result2) {
						handle(result2);
						resolve(result2);
						return;
					});
				}
			});
		}}};
		var client = new vshaxe_server_LanguageClient("haxe","Haxe",{ run : { module : this.serverModulePath, options : { env : process.env}}, debug : { module : this.serverModulePath, options : { env : process.env, execArgv : ["--nolazy","--inspect=6504"]}}},clientOptions);
		var argumentsChanged = false;
		var argumentChangeListenerDisposable = this.displayArguments._onDidChangeArguments.event(function(_) {
			argumentsChanged = true;
			return argumentsChanged;
		});
		this.restartDisposables.push(argumentChangeListenerDisposable);
		client.onReady().then(function(_1) {
			client.outputChannel.appendLine("Haxe language server started");
			HxOverrides.remove(_gthis.restartDisposables,argumentChangeListenerDisposable);
			argumentChangeListenerDisposable.dispose();
			if(argumentsChanged) {
				var $arguments = [];
				if(_gthis.displayArguments.arguments != null) {
					$arguments = _gthis.displayArguments.arguments;
				}
				_gthis.sendNotification("haxe/didChangeDisplayArguments",{ 'arguments' : $arguments});
			}
			_gthis.restartDisposables.push(_gthis.displayArguments._onDidChangeArguments.event(function(arguments1) {
				_gthis.sendNotification("haxe/didChangeDisplayArguments",{ 'arguments' : arguments1});
				return;
			}));
			_gthis.restartDisposables.push(new vshaxe_server_PackageInserter(_gthis.hxFileWatcher,_gthis));
			_gthis.onNotification("haxe/progressStart",$bind(_gthis,_gthis.onStartProgress));
			_gthis.onNotification("haxe/progressStop",$bind(_gthis,_gthis.onStopProgress));
			_gthis.onNotification("haxe/didChangeDisplayPort",$bind(_gthis,_gthis.onDidChangeDisplayPort));
			_gthis.onNotification("haxe/didRunGlobalDiagnostics",$bind(_gthis,_gthis.onDidRunGlobalDiangostics));
			_gthis.onNotification("haxe/didRunHaxeMethod",$bind(_gthis,_gthis.onDidRunHaxeMethodCallback));
			_gthis.onNotification("haxe/didChangeRequestQueue",$bind(_gthis,_gthis.onDidChangeRequestQueueCallback));
			_gthis.onNotification("haxe/cacheBuildFailed",$bind(_gthis,_gthis.onCacheBuildFailed));
			_gthis.onNotification("haxe/didDetectOldPreview",$bind(_gthis,_gthis.onDidDetectOldPreview));
			client.onDidChangeState($bind(_gthis,_gthis.onDidChangeState));
		});
		this.restartDisposables.push(client.start());
		this.client = client;
	}
	prepareDisplayServerConfig() {
		var path = this.haxeExecutable.configuration.executable;
		var env = this.haxeExecutable.configuration.env;
		var haxeConfig = Vscode.workspace.getConfiguration("haxe");
		var $arguments = haxeConfig.get("displayServer.arguments",[]);
		var print = haxeConfig.get("displayServer.print",{ completion : false, reusing : false});
		if(!this.haxeExecutable.isConfigured()) {
			var displayServerConfig = haxeConfig.get("displayServer");
			var merge = function(conf) {
				if(conf.haxePath != null) {
					path = conf.haxePath;
				}
				if(conf.env != null) {
					env = conf.env;
				}
			};
			if(displayServerConfig != null) {
				merge(displayServerConfig);
				var systemConfig = Reflect.field(displayServerConfig,vshaxe_helper_HaxeExecutable.SYSTEM_KEY);
				if(systemConfig != null) {
					merge(systemConfig);
				}
			}
		}
		this.displayServerConfig = { path : path, env : env, 'arguments' : $arguments, print : print};
		var oldSerialized = this.displayServerConfigSerialized;
		this.displayServerConfigSerialized = JSON.stringify(this.displayServerConfig);
		return this.displayServerConfigSerialized != oldSerialized;
	}
	onStartProgress(data) {
		var _gthis = this;
		Vscode.window.withProgress({ location : vscode__$ProgressLocation_ProgressLocation_$Impl_$.Window, title : data.title},function(_,_1) {
			return new Promise(function(resolve,_2) {
				var v = function() {
					resolve(null);
				};
				_gthis.progresses.h[data.id] = v;
			});
		});
	}
	onStopProgress(data) {
		var stop = this.progresses.h[data.id];
		if(stop != null) {
			this.progresses.remove(data.id);
			stop();
		}
	}
	onDidChangeDisplayPort(data) {
		this.displayPort = data.port;
		this.api.displayPort = data.port;
	}
	restart() {
		if(this.client != null && this.client.outputChannel != null) {
			this.client.outputChannel.dispose();
		}
		var _g = 0;
		var _g1 = this.restartDisposables;
		while(_g < _g1.length) _g1[_g++].dispose();
		this.restartDisposables = [];
		this.stopAllProgresses();
		this.start();
	}
	stopAllProgresses() {
		var stop = this.progresses.iterator();
		while(stop.hasNext()) (stop.next())();
		this.progresses = new haxe_ds_IntMap();
	}
	runGlobalDiagnostics() {
		this.sendNotification("haxe/runGlobalDiagnostics");
	}
	runMethod(method,params) {
		return this.sendRequest("haxe/runMethod",{ method : method, params : params});
	}
	onDidRunGlobalDiangostics(_) {
		Vscode.commands.executeCommand("workbench.action.problems.focus");
	}
	onDidRunHaxeMethodCallback(data) {
		this._onDidRunHaxeMethod.fire(data);
	}
	onDidChangeRequestQueueCallback(data) {
		this._onDidChangeRequestQueue.fire(data.queue);
	}
	onCacheBuildFailed(_) {
		var message = "Unable to build cache - completion features may be slower than expected. Try fixing the error(s) and restarting the language server.";
		var showMessage = null;
		var _gthis = this;
		showMessage = function(option1,option2) {
			Vscode.window.showWarningMessage(message,option1,option2).then(function(selection) {
				if(selection == null) {
					return;
				}
				if(selection != null) {
					switch(selection) {
					case "Retry":
						_gthis.restart();
						break;
					case "Show Error":
						if(_gthis.client != null) {
							_gthis.client.outputChannel.show();
							showMessage("Retry",undefined);
						}
						break;
					default:
					}
				}
			});
		};
		showMessage("Show Error","Retry");
	}
	onDidDetectOldPreview(data) {
		var globalState = this.context.globalState;
		if(globalState.get(vshaxe_server_LanguageServer.DontShowOldPreviewHintAgainKey,false)) {
			return;
		}
		Vscode.window.showInformationMessage("Old Haxe 4 preview build detected" + (data == null ? "" : " (" + data.preview + ")") + ". Consider upgrading to Haxe 4.0.0-rc.2 for improved completion features and stability.","Visit Download Page","Don't Show Again").then(function(selection) {
			if(selection == null) {
				return;
			}
			if(selection != null) {
				switch(selection) {
				case "Don't Show Again":
					globalState.update(vshaxe_server_LanguageServer.DontShowOldPreviewHintAgainKey,true);
					break;
				case "Visit Download Page":
					Vscode.env.openExternal(vscode_Uri.parse("https://haxe.org/download/version/4.0.0-rc.2/"));
					break;
				default:
				}
			}
		});
	}
	onDidChangeState(event) {
		if(event.newState == 1) {
			this.stopAllProgresses();
		}
	}
}
vshaxe_server_LanguageServer.__name__ = true;
class vshaxe_server_PackageInserter {
	constructor(watcher,server) {
		var _gthis = this;
		this.server = server;
		this.createEvent = watcher.onDidCreate(function(uri) {
			var editor = Vscode.window.activeTextEditor;
			if(editor == null || editor.document.uri.fsPath != uri.fsPath) {
				_gthis.lastCreatedFile = uri;
			} else {
				_gthis.insertPackageStatement(editor);
			}
		});
		this.openEvent = Vscode.window.onDidChangeActiveTextEditor(function(editor1) {
			if(editor1 != null && _gthis.lastCreatedFile != null && editor1.document.uri.fsPath == _gthis.lastCreatedFile.fsPath) {
				_gthis.insertPackageStatement(editor1);
			}
		});
	}
	insertPackageStatement(editor) {
		this.lastCreatedFile = null;
		if(editor.document.getText(new vscode_Range(0,0,0,1)).length > 0) {
			return;
		}
		this.server.sendRequest("haxe/determinePackage",{ fsPath : editor.document.uri.fsPath}).then(function(result) {
			if(result.pack == "") {
				return;
			}
			editor.edit(function(edit) {
				edit.insert(new vscode_Position(0,0),"package " + result.pack + ";\n\n");
			});
		});
	}
	dispose() {
		this.createEvent.dispose();
		this.openEvent.dispose();
	}
}
vshaxe_server_PackageInserter.__name__ = true;
class vshaxe_tasks_HaxeTaskProvider {
	constructor(taskConfiguration,displayArguments,haxeDisplayArgumentsProvider) {
		this.taskConfiguration = taskConfiguration;
		this.displayArguments = displayArguments;
		this.haxeDisplayArgumentsProvider = haxeDisplayArgumentsProvider;
		Vscode.tasks.registerTaskProvider("haxe",this);
	}
	provideTasks(token) {
		if(this.haxeDisplayArgumentsProvider.configurations.length == 0 || this.displayArguments.arguments == null) {
			return [];
		}
		return [this.taskConfiguration.createTask({ type : "haxe", args : "active configuration"},"active configuration",this.displayArguments.arguments)];
	}
	resolveTask(task,token) {
		return task;
	}
}
vshaxe_tasks_HaxeTaskProvider.__name__ = true;
class vshaxe_tasks_HxmlTaskProvider {
	constructor(taskConfiguration,hxmlDiscovery) {
		this.taskConfiguration = taskConfiguration;
		this.hxmlDiscovery = hxmlDiscovery;
		Vscode.tasks.registerTaskProvider("hxml",this);
	}
	provideTasks(token) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.hxmlDiscovery.files;
		while(_g1 < _g2.length) {
			var file = _g2[_g1];
			++_g1;
			_g.push(this.taskConfiguration.createTask({ type : "hxml", file : file},file,[file]));
		}
		return _g;
	}
	resolveTask(task,token) {
		return task;
	}
}
vshaxe_tasks_HxmlTaskProvider.__name__ = true;
class vshaxe_tasks_TaskConfiguration {
	constructor(haxeExecutable,problemMatchers,server,api) {
		var _gthis = this;
		this.haxeExecutable = haxeExecutable;
		this.problemMatchers = problemMatchers;
		this.server = server;
		this.api = api;
		this.enableCompilationServer = Vscode.workspace.getConfiguration("haxe").get("enableCompilationServer",true);
		var presentation = Vscode.workspace.getConfiguration("haxe").get("taskPresentation",{ });
		var _g = presentation.reveal;
		var tmp;
		if(_g == null) {
			tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Always;
		} else {
			switch(_g) {
			case "always":
				tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Always;
				break;
			case "never":
				tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Never;
				break;
			case "silent":
				tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Silent;
				break;
			default:
				tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Always;
			}
		}
		var _g1 = presentation.panel;
		var tmp1;
		if(_g1 == null) {
			tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Shared;
		} else {
			switch(_g1) {
			case "dedicated":
				tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Dedicated;
				break;
			case "new":
				tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.New;
				break;
			case "shared":
				tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Shared;
				break;
			default:
				tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Shared;
			}
		}
		this.taskPresentation = { echo : presentation.echo, reveal : tmp, focus : presentation.focus, panel : tmp1, showReuseMessage : presentation.showReuseMessage, clear : presentation.clear};
		var writeableApi = this.api;
		writeableApi.enableCompilationServer = this.enableCompilationServer;
		writeableApi.taskPresentation = this.taskPresentation;
		Vscode.workspace.onDidChangeConfiguration(function(_) {
			_gthis.update();
			return;
		});
	}
	update() {
		this.enableCompilationServer = Vscode.workspace.getConfiguration("haxe").get("enableCompilationServer",true);
		var presentation = Vscode.workspace.getConfiguration("haxe").get("taskPresentation",{ });
		var _g = presentation.reveal;
		var tmp;
		if(_g == null) {
			tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Always;
		} else {
			switch(_g) {
			case "always":
				tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Always;
				break;
			case "never":
				tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Never;
				break;
			case "silent":
				tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Silent;
				break;
			default:
				tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Always;
			}
		}
		var _g1 = presentation.panel;
		var tmp1;
		if(_g1 == null) {
			tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Shared;
		} else {
			switch(_g1) {
			case "dedicated":
				tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Dedicated;
				break;
			case "new":
				tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.New;
				break;
			case "shared":
				tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Shared;
				break;
			default:
				tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Shared;
			}
		}
		this.taskPresentation = { echo : presentation.echo, reveal : tmp, focus : presentation.focus, panel : tmp1, showReuseMessage : presentation.showReuseMessage, clear : presentation.clear};
		var writeableApi = this.api;
		writeableApi.enableCompilationServer = this.enableCompilationServer;
		writeableApi.taskPresentation = this.taskPresentation;
	}
	createTask(definition,name,args) {
		var exectuable = this.haxeExecutable.configuration.executable;
		if(this.server.displayPort != null && this.enableCompilationServer) {
			args = ["--connect",Std.string(this.server.displayPort)].concat(args);
		}
		var task = new vscode_Task(definition,vscode__$TaskScope_TaskScope_$Impl_$.Workspace,name,"haxe",new vscode_ProcessExecution(exectuable,args,{ env : this.haxeExecutable.configuration.env}),this.problemMatchers);
		task.group = vscode_TaskGroup.Build;
		task.presentationOptions = this.taskPresentation;
		return task;
	}
}
vshaxe_tasks_TaskConfiguration.__name__ = true;
class vshaxe_view_HaxeServerViewContainer {
	constructor(context,server) {
		var _gthis = this;
		this.methodTreeView = new vshaxe_view_methods_MethodTreeView(context,server);
		new vshaxe_view_cache_CacheTreeView(context,server);
		this.enabled = Vscode.workspace.getConfiguration("haxe").get("enableServerView",false);
		Vscode.commands.executeCommand("setContext","enableHaxeServerView",this.enabled);
		this.methodTreeView.enabled = this.enabled;
		Vscode.workspace.onDidChangeConfiguration(function(_) {
			_gthis.update();
			return;
		});
	}
	update() {
		this.enabled = Vscode.workspace.getConfiguration("haxe").get("enableServerView",false);
		Vscode.commands.executeCommand("setContext","enableHaxeServerView",this.enabled);
		this.methodTreeView.enabled = this.enabled;
	}
}
vshaxe_view_HaxeServerViewContainer.__name__ = true;
class vshaxe_view_cache_CacheTreeView {
	constructor(context,server) {
		this.getParent = function(node) {
			return node.parent;
		};
		this.skipRefresh = new haxe_ds_ObjectMap();
		this.didChangeTreeData = new vscode_EventEmitter();
		this.context = context;
		this.server = server;
		this.onDidChangeTreeData = this.didChangeTreeData.event;
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "cache.copyNodeValue",$bind(this,this.copyNodeValue));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "cache.reloadNode",$bind(this,this.reloadNode));
		Vscode.window.registerTreeDataProvider("haxe.cache",this);
		this.view = Vscode.window.createTreeView("haxe.cache",{ treeDataProvider : this, showCollapseAll : true});
	}
	getTreeItem(node) {
		return node;
	}
	getChildren(node) {
		var _gthis = this;
		if(node == null) {
			return [new vshaxe_view_cache_Node("server",null,vshaxe_view_cache_Kind.ServerRoot),new vshaxe_view_cache_Node("memory",null,vshaxe_view_cache_Kind.MemoryRoot)];
		}
		var children = this.skipRefresh.h[node.__id__];
		if(children != null) {
			this.skipRefresh.remove(node);
			return children;
		} else {
			var node1 = node;
			var updateCount = function(nodes) {
				node1.description = nodes.length == null ? "null" : "" + nodes.length;
				_gthis.skipRefresh.set(node1,nodes);
				_gthis.didChangeTreeData.fire(node1);
			};
			var _g = node1.kind;
			switch(_g[1]) {
			case 0:
				return this.server.runMethod("server/contexts").then(function(result) {
					var nodes1 = [];
					var _g1 = 0;
					while(_g1 < result.length) {
						var ctx = result[_g1];
						++_g1;
						haxe_ds_ArraySort.sort(ctx.defines,function(kv1,kv2) {
							return Reflect.compare(kv1.key,kv2.key);
						});
						nodes1.push(new vshaxe_view_cache_Node(ctx.platform,ctx.desc,vshaxe_view_cache_Kind.Context(ctx)));
					}
					return nodes1;
				},function(reject) {
					return reject;
				});
			case 1:
				return this.server.runMethod("server/memory").then(function(result1) {
					var nodes2 = [];
					nodes2.push(new vshaxe_view_cache_Node("overview",null,vshaxe_view_cache_Kind.StringMapping([{ key : "total cache", value : vshaxe_view_cache_CacheTreeView.formatSize(result1.memory.totalCache)},{ key : "haxelib cache", value : vshaxe_view_cache_CacheTreeView.formatSize(result1.memory.haxelibCache)},{ key : "parser cache", value : vshaxe_view_cache_CacheTreeView.formatSize(result1.memory.parserCache)},{ key : "module cache", value : vshaxe_view_cache_CacheTreeView.formatSize(result1.memory.moduleCache)}]),node1));
					var _g2 = 0;
					var _g11 = result1.contexts;
					while(_g2 < _g11.length) {
						var ctx1 = _g11[_g2];
						++_g2;
						nodes2.push(new vshaxe_view_cache_Node(ctx1.context == null ? "?" : "" + ctx1.context.platform + " (" + ctx1.context.desc + ", " + ctx1.context.index + ")",vshaxe_view_cache_CacheTreeView.formatSize(ctx1.size),vshaxe_view_cache_Kind.ModuleMemory(ctx1.modules),node1));
					}
					return nodes2;
				},function(reject1) {
					return reject1;
				});
			case 2:
				return _g[2].map(function(sizeResult) {
					return new vshaxe_view_cache_Node(sizeResult.path,vshaxe_view_cache_CacheTreeView.formatSize(sizeResult.size),vshaxe_view_cache_Kind.ModuleTypeMemory(sizeResult.types),node1);
				});
			case 3:
				return _g[2].map(function(sizeResult1) {
					var kv = sizeResult1.fields.map(function(sizeResult2) {
						return { key : sizeResult2.path, value : vshaxe_view_cache_CacheTreeView.formatSize(sizeResult2.size)};
					});
					return new vshaxe_view_cache_Node(sizeResult1.path,vshaxe_view_cache_CacheTreeView.formatSize(sizeResult1.size),vshaxe_view_cache_Kind.StringMapping(kv),node1);
				});
			case 4:
				var _g3 = _g[2];
				return [new vshaxe_view_cache_Node("index","" + _g3.index,vshaxe_view_cache_Kind.Leaf,node1),new vshaxe_view_cache_Node("desc",_g3.desc,vshaxe_view_cache_Kind.Leaf,node1),new vshaxe_view_cache_Node("signature",_g3.signature,vshaxe_view_cache_Kind.Leaf,node1),new vshaxe_view_cache_Node("class paths",Std.string(_g3.classPaths.length),vshaxe_view_cache_Kind.StringList(_g3.classPaths),node1),new vshaxe_view_cache_Node("defines",Std.string(_g3.defines.length),vshaxe_view_cache_Kind.StringMapping(_g3.defines),node1),new vshaxe_view_cache_Node("modules","?",vshaxe_view_cache_Kind.ContextModules(_g3),node1),new vshaxe_view_cache_Node("files","?",vshaxe_view_cache_Kind.ContextFiles(_g3),node1)];
			case 5:
				var ctx2 = _g[2];
				return this.server.runMethod("server/modules",{ signature : ctx2.signature}).then(function(result2) {
					var nodes3 = [];
					haxe_ds_ArraySort.sort(result2,Reflect.compare);
					var _g4 = 0;
					while(_g4 < result2.length) {
						var s = result2[_g4];
						++_g4;
						nodes3.push(new vshaxe_view_cache_Node(s,null,vshaxe_view_cache_Kind.ModuleInfo(ctx2.signature,s)));
					}
					updateCount(nodes3);
					return nodes3;
				},function(reject2) {
					return reject2;
				});
			case 6:
				return this.server.runMethod("server/files",{ signature : _g[2].signature}).then(function(result3) {
					var nodes4 = result3.map(function(file) {
						return new vshaxe_view_cache_Node(file.file,null,vshaxe_view_cache_Kind.StringMapping([{ key : "mtime", value : "" + file.time},{ key : "package", value : file.pack}]),node1);
					});
					updateCount(nodes4);
					return nodes4;
				},function(reject3) {
					return reject3;
				});
			case 7:
				return this.server.runMethod("server/module",{ signature : _g[2], path : _g[3]}).then(function(result4) {
					var types = result4.types.map(function(path) {
						return path.typeName;
					});
					haxe_ds_ArraySort.sort(types,Reflect.compare);
					return [new vshaxe_view_cache_Node("id","" + result4.id,vshaxe_view_cache_Kind.Leaf,node1),new vshaxe_view_cache_Node("path",vshaxe_view_cache_CacheTreeView.printPath(result4.path),vshaxe_view_cache_Kind.Leaf,node1),new vshaxe_view_cache_Node("file",result4.file,vshaxe_view_cache_Kind.Leaf,node1),new vshaxe_view_cache_Node("sign",result4.sign,vshaxe_view_cache_Kind.Leaf,node1),new vshaxe_view_cache_Node("types",types.length == null ? "null" : "" + types.length,vshaxe_view_cache_Kind.StringList(types),node1),new vshaxe_view_cache_Node("dependencies",Std.string(result4.dependencies.length),vshaxe_view_cache_Kind.ModuleList(result4.dependencies),node1)];
				},function(reject4) {
					return reject4;
				});
			case 8:
				var _g41 = _g[2];
				var nodes5 = [];
				var _g5 = 0;
				while(_g5 < _g41.length) {
					var $module = _g41[_g5];
					++_g5;
					nodes5.push(new vshaxe_view_cache_Node($module.path,null,vshaxe_view_cache_Kind.ModuleInfo($module.sign,$module.path)));
				}
				return nodes5;
			case 9:
				return _g[2].map(function(s1) {
					return new vshaxe_view_cache_Node(s1,null,vshaxe_view_cache_Kind.Leaf,node1);
				});
			case 10:
				return _g[2].map(function(kv3) {
					return new vshaxe_view_cache_Node(kv3.key,kv3.value,vshaxe_view_cache_Kind.Leaf,node1);
				});
			case 11:
				return [];
			}
		}
	}
	copyNodeValue(node) {
		var printKv = function(kv) {
			return kv.map(function(kv1) {
				return "" + kv1.key + "=" + kv1.value;
			}).join(" ");
		};
		var value;
		var _g = node.kind;
		switch(_g[1]) {
		case 4:
			var _g2 = _g[2];
			var buf_b = "";
			var add = function(key,value1) {
				buf_b += Std.string("" + key + ": " + value1 + "\n");
			};
			add("index","" + _g2.index);
			add("desc",_g2.desc);
			add("signature",_g2.signature);
			add("platform",_g2.platform);
			add("classPaths",_g2.classPaths.join(" "));
			add("defines",printKv(_g2.defines));
			value = buf_b;
			break;
		case 9:
			value = _g[2].join(" ");
			break;
		case 10:
			value = printKv(_g[2]);
			break;
		default:
			throw new js__$Boot_HaxeError(false);
		}
		Vscode.env.clipboard.writeText(value);
	}
	reloadNode(node) {
		this.didChangeTreeData.fire(node);
	}
	static printPath(path) {
		var buf_b = "";
		if(path.pack.length > 0) {
			buf_b += Std.string(path.pack.join("."));
			buf_b += String.fromCodePoint(46);
		}
		buf_b += Std.string(path.moduleName);
		if(path.typeName != null) {
			buf_b += String.fromCodePoint(46);
			buf_b += Std.string(path.typeName);
		}
		return buf_b;
	}
	static formatSize(size) {
		if(size < 1024) {
			return size + " B";
		} else if(size < 1048576) {
			return (size >>> 10) + " KB";
		} else {
			var size1 = Std.string(size / 1048576);
			var offset = size1.indexOf(".");
			if(offset < 0) {
				return size1 + " MB";
			} else {
				return HxOverrides.substr(size1,0,offset + 2) + " MB";
			}
		}
	}
}
vshaxe_view_cache_CacheTreeView.__name__ = true;
var vshaxe_view_cache_Kind = { __ename__ : true, __constructs__ : ["ServerRoot","MemoryRoot","ModuleMemory","ModuleTypeMemory","Context","ContextModules","ContextFiles","ModuleInfo","ModuleList","StringList","StringMapping","Leaf"] };
vshaxe_view_cache_Kind.ServerRoot = ["ServerRoot",0];
vshaxe_view_cache_Kind.ServerRoot.toString = $estr;
vshaxe_view_cache_Kind.ServerRoot.__enum__ = vshaxe_view_cache_Kind;
vshaxe_view_cache_Kind.MemoryRoot = ["MemoryRoot",1];
vshaxe_view_cache_Kind.MemoryRoot.toString = $estr;
vshaxe_view_cache_Kind.MemoryRoot.__enum__ = vshaxe_view_cache_Kind;
vshaxe_view_cache_Kind.ModuleMemory = function(types) { var $x = ["ModuleMemory",2,types]; $x.__enum__ = vshaxe_view_cache_Kind; $x.toString = $estr; return $x; }
vshaxe_view_cache_Kind.ModuleTypeMemory = function(types) { var $x = ["ModuleTypeMemory",3,types]; $x.__enum__ = vshaxe_view_cache_Kind; $x.toString = $estr; return $x; }
vshaxe_view_cache_Kind.Context = function(ctx) { var $x = ["Context",4,ctx]; $x.__enum__ = vshaxe_view_cache_Kind; $x.toString = $estr; return $x; }
vshaxe_view_cache_Kind.ContextModules = function(ctx) { var $x = ["ContextModules",5,ctx]; $x.__enum__ = vshaxe_view_cache_Kind; $x.toString = $estr; return $x; }
vshaxe_view_cache_Kind.ContextFiles = function(ctx) { var $x = ["ContextFiles",6,ctx]; $x.__enum__ = vshaxe_view_cache_Kind; $x.toString = $estr; return $x; }
vshaxe_view_cache_Kind.ModuleInfo = function(sign,path) { var $x = ["ModuleInfo",7,sign,path]; $x.__enum__ = vshaxe_view_cache_Kind; $x.toString = $estr; return $x; }
vshaxe_view_cache_Kind.ModuleList = function(modules) { var $x = ["ModuleList",8,modules]; $x.__enum__ = vshaxe_view_cache_Kind; $x.toString = $estr; return $x; }
vshaxe_view_cache_Kind.StringList = function(strings) { var $x = ["StringList",9,strings]; $x.__enum__ = vshaxe_view_cache_Kind; $x.toString = $estr; return $x; }
vshaxe_view_cache_Kind.StringMapping = function(mapping) { var $x = ["StringMapping",10,mapping]; $x.__enum__ = vshaxe_view_cache_Kind; $x.toString = $estr; return $x; }
vshaxe_view_cache_Kind.Leaf = ["Leaf",11];
vshaxe_view_cache_Kind.Leaf.toString = $estr;
vshaxe_view_cache_Kind.Leaf.__enum__ = vshaxe_view_cache_Kind;
class vshaxe_view_cache_Node extends vscode_TreeItem {
	constructor(label,description,kind,parent) {
		super(label,kind == vshaxe_view_cache_Kind.Leaf ? vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.None : vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Collapsed);
		this.description = description;
		this.parent = parent;
		this.kind = kind;
		switch(kind[1]) {
		case 0:case 1:
			this.contextValue = "reloadable";
			break;
		case 4:
			this.contextValue = "copyable";
			break;
		case 5:
			this.contextValue = "reloadable";
			break;
		case 6:
			this.contextValue = "reloadable";
			break;
		case 7:
			this.contextValue = "reloadable";
			break;
		case 9:
			this.contextValue = "copyable";
			break;
		case 10:
			this.contextValue = "copyable";
			break;
		default:
		}
	}
}
vshaxe_view_cache_Node.__name__ = true;
class vshaxe_view_dependencies_DependencyExtractor {
	static extractDependencies(args,cwd) {
		var result = { libs : [], classPaths : [], hxmls : []};
		if(args == null) {
			return result;
		}
		var processHxml = function(hxmlFile,cwd1) {
			hxmlFile = vshaxe_helper_PathHelper.absolutize(hxmlFile,cwd1);
			result.hxmls.push(hxmlFile);
			if(hxmlFile == null || !sys_FileSystem.exists(hxmlFile)) {
				return [];
			}
			return vshaxe_helper_HxmlParser.parseFile(js_node_Fs.readFileSync(hxmlFile,{ encoding : "utf8"}));
		};
		var processLines = null;
		processLines = function(lines) {
			var _g = 0;
			while(_g < lines.length) {
				var line = lines[_g];
				++_g;
				switch(line[1]) {
				case 1:
					var _g2 = line[2];
					if(StringTools.endsWith(_g2,".hxml")) {
						var processLines1 = processHxml(_g2,cwd);
						processLines(processLines1);
					}
					break;
				case 2:
					var _g1 = line[3];
					switch(line[2]) {
					case "--library":case "-L":case "-lib":
						result.libs.push(_g1);
						break;
					case "--cwd":case "-C":
						if(haxe_io_Path.isAbsolute(_g1)) {
							cwd = _g1;
						} else {
							cwd = haxe_io_Path.join([cwd,_g1]);
						}
						break;
					case "--class-path":case "-cp":case "-p":
						result.classPaths.push(_g1);
						break;
					default:
					}
					break;
				default:
				}
			}
		};
		var tmp = vshaxe_helper_HxmlParser.parseArray(args);
		processLines(tmp);
		return result;
	}
}
vshaxe_view_dependencies_DependencyExtractor.__name__ = true;
class vshaxe_view_dependencies_DependencyResolver {
	static resolveDependencies(dependencies,haxeExecutable) {
		var paths = [];
		var _g = 0;
		var _g1 = dependencies.libs;
		while(_g < _g1.length) paths = paths.concat(vshaxe_view_dependencies_DependencyResolver.resolveHaxelib(_g1[_g++]));
		paths = paths.concat(dependencies.classPaths);
		paths = vshaxe_view_dependencies_DependencyResolver.pruneSubdirectories(paths);
		var infos = [];
		if(vshaxe_view_dependencies_DependencyResolver.get_haxelibRepo() != null) {
			var _g2 = 0;
			var _g3 = paths.map(vshaxe_view_dependencies_DependencyResolver.getDependencyInfo);
			while(_g2 < _g3.length) {
				var info = _g3[_g2];
				++_g2;
				if(info != null) {
					infos.push(info);
				}
			}
		}
		var stdLibPath = vshaxe_view_dependencies_DependencyResolver.getStandardLibraryPath(haxeExecutable.configuration);
		if(stdLibPath != null && sys_FileSystem.exists(stdLibPath)) {
			infos.push(vshaxe_view_dependencies_DependencyResolver.getStandardLibraryInfo(stdLibPath,haxeExecutable.configuration.executable));
		}
		return infos;
	}
	static get_haxelibRepo() {
		if(vshaxe_view_dependencies_DependencyResolver._haxelibRepo == null) {
			var output = vshaxe_view_dependencies_DependencyResolver.getProcessOutput("haxelib config")[0];
			if(output == null) {
				console.log("src/vshaxe/view/dependencies/DependencyResolver.hx:51:","`haxelib config` call failed, Haxe Dependencies won't be populated.");
			} else {
				vshaxe_view_dependencies_DependencyResolver._haxelibRepo = haxe_io_Path.normalize(output);
			}
		}
		return vshaxe_view_dependencies_DependencyResolver._haxelibRepo;
	}
	static resolveHaxelib(lib) {
		var paths = [];
		var _g = 0;
		var _g1 = vshaxe_view_dependencies_DependencyResolver.getProcessOutput("haxelib path " + lib);
		while(_g < _g1.length) {
			var potentialPath = haxe_io_Path.normalize(_g1[_g++]);
			if(sys_FileSystem.exists(potentialPath)) {
				paths.push(potentialPath);
			}
		}
		return paths;
	}
	static getProcessOutput(command) {
		try {
			var oldCwd = process.cwd();
			if(Vscode.workspace.workspaceFolders != null) {
				process.chdir(Vscode.workspace.workspaceFolders[0].uri.fsPath);
			}
			var result = js_node_ChildProcess.execSync(command);
			process.chdir(oldCwd);
			var lines = result.toString().split("\n");
			var _g = [];
			var _g1 = 0;
			while(_g1 < lines.length) _g.push(StringTools.trim(lines[_g1++]));
			return _g;
		} catch( e ) {
			return [];
		}
	}
	static pruneSubdirectories(paths) {
		paths = paths.map(haxe_io_Path.addTrailingSlash);
		return paths.filter(function(path) {
			return !Lambda.exists(paths,function(p) {
				if(p != path) {
					return StringTools.startsWith(path,p);
				} else {
					return false;
				}
			});
		});
	}
	static getDependencyInfo(path) {
		if(Vscode.workspace.workspaceFolders == null) {
			return null;
		}
		var rootPath = Vscode.workspace.workspaceFolders[0].uri.fsPath;
		var absPath = vshaxe_helper_PathHelper.absolutize(path,rootPath);
		var haxelibRepo = vshaxe_view_dependencies_DependencyResolver.get_haxelibRepo();
		if(haxelibRepo == null || !sys_FileSystem.exists(absPath)) {
			return null;
		}
		if(absPath.indexOf(haxelibRepo) == -1) {
			if(absPath.indexOf(haxe_io_Path.normalize(rootPath)) == -1) {
				var haxelibInfo = vshaxe_view_dependencies_DependencyResolver.searchHaxelibJson(absPath);
				if(haxelibInfo == null) {
					return { name : path, version : null, path : absPath};
				}
				return haxelibInfo;
			}
			return null;
		}
		path = StringTools.replace(absPath,haxelibRepo + "/","");
		var segments = path.split("/");
		var name = segments[0];
		var version = segments[1];
		path = "" + haxelibRepo + "/" + name;
		if(name != null) {
			name = StringTools.replace(name,",",".");
		}
		if(version != null) {
			path += "/" + version;
			version = StringTools.replace(version,",",".");
		} else {
			version = path;
		}
		if(!sys_FileSystem.exists(path)) {
			return null;
		}
		return { name : name, version : version, path : path};
	}
	static searchHaxelibJson(path,levels) {
		if(levels == null) {
			levels = 3;
		}
		if(levels <= 0) {
			return null;
		}
		var haxelibFile = haxe_io_Path.join([path,"haxelib.json"]);
		if(sys_FileSystem.exists(haxelibFile)) {
			var content = JSON.parse(js_node_Fs.readFileSync(haxelibFile,{ encoding : "utf8"}));
			if(content.name == null) {
				return null;
			}
			path = haxe_io_Path.normalize(path);
			return { name : content.name, version : "dev", path : path};
		}
		return vshaxe_view_dependencies_DependencyResolver.searchHaxelibJson(haxe_io_Path.join([path,".."]),levels - 1);
	}
	static getStandardLibraryPath(haxeExecutable) {
		var path = process.env["HAXE_STD_PATH"];
		if(path != null) {
			return path;
		}
		if(Sys.systemName() == "Windows") {
			var path1;
			if(haxeExecutable.isCommand) {
				var exectuable = vshaxe_view_dependencies_DependencyResolver.getProcessOutput("where " + haxeExecutable.executable)[0];
				if(exectuable == null) {
					return null;
				}
				path1 = exectuable;
			} else {
				path1 = haxeExecutable.executable;
			}
			return haxe_io_Path.join([haxe_io_Path.directory(path1),"std"]);
		} else {
			if(sys_FileSystem.exists("/usr/local/share/haxe/std/")) {
				return "/usr/local/share/haxe/std/";
			}
			if(sys_FileSystem.exists("/usr/local/lib/haxe/std/")) {
				return "/usr/local/lib/haxe/std/";
			}
			if(sys_FileSystem.exists("/usr/share/haxe/std/")) {
				return "/usr/share/haxe/std/";
			}
			if(sys_FileSystem.exists("/usr/lib/haxe/std/")) {
				return "/usr/lib/haxe/std/";
			}
		}
		return null;
	}
	static getStandardLibraryInfo(path,haxeExecutable) {
		var version = "?";
		var result = js_node_ChildProcess.spawnSync(haxeExecutable,["-version"]);
		if(result != null && result.stderr != null) {
			var output = StringTools.trim(result.stderr.toString());
			if(output == "") {
				output = StringTools.trim(result.stdout.toString());
			}
			if(output != null) {
				version = StringTools.trim(output.split(" ")[0]);
			}
		}
		return { name : "haxe", path : path, version : version};
	}
}
vshaxe_view_dependencies_DependencyResolver.__name__ = true;
class vshaxe_view_dependencies_DependencyTreeView {
	constructor(context,displayArguments,haxeExecutable) {
		this.getParent = function(node) {
			return node.parent;
		};
		this._onDidChangeTreeData = new vscode_EventEmitter();
		this.refreshNeeded = true;
		this.dependencyNodes = [];
		this.relevantHxmls = [];
		var _gthis = this;
		this.context = context;
		this.displayArguments = displayArguments.arguments;
		this.haxeExecutable = haxeExecutable;
		this.onDidChangeTreeData = this._onDidChangeTreeData.event;
		this.autoRevealEnabled = Vscode.workspace.getConfiguration("explorer").get("autoReveal",true);
		Vscode.window.registerTreeDataProvider("haxe.dependencies",this);
		this.view = Vscode.window.createTreeView("haxe.dependencies",{ treeDataProvider : this, showCollapseAll : true});
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "refreshDependencies",$bind(this,this.refresh));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.openTextDocument",$bind(this,this.openTextDocument));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.refresh",$bind(this,this.refresh));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.openPreview",$bind(this,this.openPreview));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.openToTheSide",$bind(this,this.openToTheSide));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.revealInExplorer",$bind(this,this.revealInExplorer));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.openInCommandPrompt",$bind(this,this.openInCommandPrompt));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.copyPath",$bind(this,this.copyPath));
		var hxmlFileWatcher = Vscode.workspace.createFileSystemWatcher("**/*.hxml");
		context.subscriptions.push(hxmlFileWatcher.onDidCreate($bind(this,this.onDidChangeHxml)));
		context.subscriptions.push(hxmlFileWatcher.onDidChange($bind(this,this.onDidChangeHxml)));
		context.subscriptions.push(hxmlFileWatcher.onDidDelete($bind(this,this.onDidChangeHxml)));
		context.subscriptions.push(hxmlFileWatcher);
		context.subscriptions.push((haxeExecutable.get_onDidChangeConfiguration())(function(_) {
			_gthis.refresh();
			return;
		}));
		context.subscriptions.push(Vscode.workspace.onDidChangeConfiguration(function(_1) {
			_gthis.updateAutoReveal();
			return;
		}));
		context.subscriptions.push(displayArguments._onDidChangeArguments.event($bind(this,this.onDidChangeDisplayArguments)));
		context.subscriptions.push(Vscode.window.onDidChangeActiveTextEditor(function(_2) {
			_gthis.autoReveal();
			return;
		}));
		context.subscriptions.push(this.view.onDidChangeVisibility(function(_3) {
			_gthis.autoReveal();
			return;
		}));
	}
	onDidChangeHxml(uri) {
		var _g = 0;
		var _g1 = this.relevantHxmls;
		while(_g < _g1.length) if(vshaxe_helper_PathHelper.areEqual(uri.fsPath,_g1[_g++])) {
			this.refresh(false);
		}
	}
	refreshDependencies() {
		if(Vscode.workspace.workspaceFolders == null) {
			return [];
		}
		var newDependencies = vshaxe_view_dependencies_DependencyExtractor.extractDependencies(this.displayArguments,Vscode.workspace.workspaceFolders[0].uri.fsPath);
		this.relevantHxmls = newDependencies.hxmls;
		if(this.dependencies != null && vshaxe_helper_ArrayHelper.equals(this.dependencies.libs,newDependencies.libs) && vshaxe_helper_ArrayHelper.equals(this.dependencies.classPaths,newDependencies.classPaths)) {
			return this.dependencyNodes;
		}
		this.dependencies = newDependencies;
		return this.updateNodes(vshaxe_view_dependencies_DependencyResolver.resolveDependencies(newDependencies,this.haxeExecutable));
	}
	updateNodes(dependencyInfos) {
		var newNodes = [];
		var _g = 0;
		while(_g < dependencyInfos.length) {
			var info = [dependencyInfos[_g]];
			++_g;
			if(Lambda.find(newNodes,(function(info1) {
				return function(d) {
					return vshaxe_helper_PathHelper.areEqual(d.path,info1[0].path);
				};
			})(info)) != null) {
				continue;
			}
			if(this.dependencies != null) {
				var oldNode = Lambda.find(this.dependencyNodes,(function(info2) {
					return function(d1) {
						return d1.path == info2[0].path;
					};
				})(info));
				if(oldNode != null) {
					newNodes.push(oldNode);
					continue;
				}
			}
			var node = this.createNode(info[0]);
			if(node != null) {
				newNodes.push(node);
			}
		}
		vshaxe_view_dependencies_Node.sort(newNodes);
		haxe_ds_ArraySort.sort(newNodes,function(node1,node2) {
			if(node1.type == vshaxe_view_dependencies_NodeType.StandardLibrary) {
				return 1;
			} else if(node2.type == vshaxe_view_dependencies_NodeType.StandardLibrary) {
				return -1;
			}
			return 0;
		});
		return newNodes;
	}
	createNode(info) {
		if(info == null) {
			return null;
		}
		var label = info.name;
		if(info.version != null) {
			label += " (" + info.version + ")";
		}
		return new vshaxe_view_dependencies_Node(null,label,info.path,info.name == "haxe" ? vshaxe_view_dependencies_NodeType.StandardLibrary : vshaxe_view_dependencies_NodeType.Haxelib);
	}
	onDidChangeDisplayArguments(displayArguments) {
		this.displayArguments = displayArguments;
		this.refresh();
	}
	updateAutoReveal() {
		this.autoRevealEnabled = Vscode.workspace.getConfiguration("explorer").get("autoReveal",true);
	}
	autoReveal() {
		var editor = Vscode.window.activeTextEditor;
		var _gthis = this;
		if(editor == null || !this.view.visible || !this.autoRevealEnabled) {
			return;
		}
		var document = editor.document;
		var loop = null;
		loop = function(nodes) {
			var _g = 0;
			while(_g < nodes.length) {
				var node = nodes[_g];
				++_g;
				if(node.type != vshaxe_view_dependencies_NodeType.File && vshaxe_helper_PathHelper.containsFile(node.path,document.fileName)) {
					var loop1 = node.get_children();
					loop(loop1);
				} else if(vshaxe_helper_PathHelper.areEqual(node.path,document.fileName)) {
					_gthis.view.reveal(node,{ select : true});
					break;
				}
			}
		};
		loop(this.dependencyNodes);
	}
	refresh(hard) {
		if(hard == null) {
			hard = true;
		}
		if(hard) {
			this.dependencies = null;
			var _g = 0;
			var _g1 = this.dependencyNodes;
			while(_g < _g1.length) _g1[_g++].refresh();
		}
		this.refreshNeeded = true;
		this._onDidChangeTreeData.fire();
	}
	getTreeItem(element) {
		return element;
	}
	getChildren(node) {
		if(this.refreshNeeded) {
			this.dependencyNodes = this.refreshDependencies();
			this.refreshNeeded = false;
		}
		if(node == null) {
			return this.dependencyNodes;
		} else {
			return node.get_children();
		}
	}
	openTextDocument(node) {
		var currentTime = new Date().getTime();
		var preview = this.previousSelection == null || this.previousSelection.node != node || currentTime - this.previousSelection.time >= 500;
		Vscode.workspace.openTextDocument(node.path).then(function(document) {
			return Vscode.window.showTextDocument(document,{ preview : preview});
		});
		this.previousSelection = { node : node, time : currentTime};
	}
	openPreview(node) {
		Vscode.commands.executeCommand("markdown.showPreview",node.path);
	}
	openToTheSide(node) {
		if(node.resourceUri != null) {
			Vscode.window.showTextDocument(node.resourceUri,{ viewColumn : vscode__$ViewColumn_ViewColumn_$Impl_$.Three});
		}
	}
	revealInExplorer(node) {
		var explorer;
		switch(Sys.systemName()) {
		case "Linux":
			explorer = "xdg-open";
			break;
		case "Mac":
			explorer = "open";
			break;
		case "Windows":
			explorer = "explorer";
			break;
		default:
			throw new js__$Boot_HaxeError("unsupported OS");
		}
		var arg = node.path;
		if(Sys.systemName() == "Windows") {
			arg = "/select,\"" + arg + "\"";
		}
		js_node_ChildProcess.spawnSync("" + explorer + " " + arg,{ shell : true, stdio : "inherit"});
	}
	openInCommandPrompt(node) {
		var cwd = node.path;
		if(node.type == vshaxe_view_dependencies_NodeType.File) {
			cwd = haxe_io_Path.directory(node.path);
		}
		Vscode.window.createTerminal({ cwd : cwd}).show();
	}
	copyPath(node) {
		Vscode.env.clipboard.writeText(vshaxe_helper_PathHelper.capitalizeDriveLetter(node.path));
	}
}
vshaxe_view_dependencies_DependencyTreeView.__name__ = true;
var vshaxe_view_dependencies_NodeType = { __ename__ : true, __constructs__ : ["File","Folder","Haxelib","StandardLibrary"] };
vshaxe_view_dependencies_NodeType.File = ["File",0];
vshaxe_view_dependencies_NodeType.File.toString = $estr;
vshaxe_view_dependencies_NodeType.File.__enum__ = vshaxe_view_dependencies_NodeType;
vshaxe_view_dependencies_NodeType.Folder = ["Folder",1];
vshaxe_view_dependencies_NodeType.Folder.toString = $estr;
vshaxe_view_dependencies_NodeType.Folder.__enum__ = vshaxe_view_dependencies_NodeType;
vshaxe_view_dependencies_NodeType.Haxelib = ["Haxelib",2];
vshaxe_view_dependencies_NodeType.Haxelib.toString = $estr;
vshaxe_view_dependencies_NodeType.Haxelib.__enum__ = vshaxe_view_dependencies_NodeType;
vshaxe_view_dependencies_NodeType.StandardLibrary = ["StandardLibrary",3];
vshaxe_view_dependencies_NodeType.StandardLibrary.toString = $estr;
vshaxe_view_dependencies_NodeType.StandardLibrary.__enum__ = vshaxe_view_dependencies_NodeType;
class vshaxe_view_dependencies_Node extends vscode_TreeItem {
	constructor(parent,label,path,type) {
		super(label);
		this.parent = parent;
		this.resourceUri = vscode_Uri.file(path);
		this.path = this.resourceUri.fsPath;
		if(type == null) {
			type = sys_FileSystem.isDirectory(path) ? vshaxe_view_dependencies_NodeType.Folder : vshaxe_view_dependencies_NodeType.File;
		}
		this.type = type;
		if(this.type != vshaxe_view_dependencies_NodeType.File) {
			this.collapsibleState = vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Collapsed;
			this.contextValue = "folder";
		} else {
			this.contextValue = "file." + haxe_io_Path.extension(path);
			this.command = { command : "haxe." + "dependencies.openTextDocument", 'arguments' : [this], title : "Open File"};
		}
	}
	refresh() {
		if(this.type == vshaxe_view_dependencies_NodeType.File || this.get_children() == null) {
			return;
		}
		var newChildren = [];
		var _gthis = this;
		this.forEachChild(function(file,path) {
			var existingNode = null;
			if(_gthis.get_children() != null) {
				existingNode = Lambda.find(_gthis.get_children(),function(node) {
					return node.label == file;
				});
			}
			if(existingNode != null) {
				existingNode.refresh();
				return newChildren.push(existingNode);
			} else {
				return newChildren.push(new vshaxe_view_dependencies_Node(_gthis,file,path));
			}
		});
		vshaxe_view_dependencies_Node.sort(newChildren);
		this._children = newChildren;
	}
	get_children() {
		if(this._children == null) {
			this._children = this.createChildren();
		}
		return this._children;
	}
	createChildren() {
		if(this.type == vshaxe_view_dependencies_NodeType.File) {
			return [];
		}
		var children = [];
		var _gthis = this;
		this.forEachChild(function(file,path) {
			return children.push(new vshaxe_view_dependencies_Node(_gthis,file,path));
		});
		vshaxe_view_dependencies_Node.sort(children);
		return children;
	}
	forEachChild(f) {
		var _g = 0;
		var _g1 = js_node_Fs.readdirSync(this.path);
		while(_g < _g1.length) {
			var file = _g1[_g];
			++_g;
			if(!this.isExcluded(file)) {
				f(file,"" + this.path + "/" + file);
			}
		}
	}
	isExcluded(file) {
		if(!(file == ".git" || file == ".svn" || file == ".hg" || file == "CVS")) {
			return file == ".DS_Store";
		} else {
			return true;
		}
	}
	static sort(nodes) {
		haxe_ds_ArraySort.sort(nodes,function(c1,c2) {
			var compare = function(a,b) {
				if(a == null || b == null) {
					return 0;
				}
				a = a.toLowerCase();
				b = b.toLowerCase();
				if(a < b) {
					return -1;
				}
				if(a > b) {
					return 1;
				}
				return 0;
			};
			if(c1.type != vshaxe_view_dependencies_NodeType.File && c2.type != vshaxe_view_dependencies_NodeType.File) {
				return compare(c1.label,c2.label);
			} else if(c1.type != vshaxe_view_dependencies_NodeType.File) {
				return -1;
			} else if(c2.type != vshaxe_view_dependencies_NodeType.File) {
				return 1;
			} else {
				return compare(c1.label,c2.label);
			}
		});
	}
}
vshaxe_view_dependencies_Node.__name__ = true;
class vshaxe_view_methods_MethodTreeView {
	constructor(context,server) {
		this.getParent = function(element) {
			return element.parent;
		};
		this.enabled = false;
		this.queue = [];
		this.methods = [];
		this._onDidChangeTreeData = new vscode_EventEmitter();
		this.context = context;
		this.server = server;
		this.onDidChangeTreeData = this._onDidChangeTreeData.event;
		var viewType = "timers";
		this.viewType = viewType;
		Vscode.commands.executeCommand("setContext","haxeMethodsViewType",Std.string(viewType));
		Vscode.window.registerTreeDataProvider("haxe.methods",this);
		this.treeView = Vscode.window.createTreeView("haxe.methods",{ treeDataProvider : this, showCollapseAll : true});
		server._onDidRunHaxeMethod.event($bind(this,this.onDidRunHaxeMethod));
		server._onDidChangeRequestQueue.event($bind(this,this.onDidChangeRequestQueue));
		var f = $bind(this,this.switchTo);
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "methods.switchToQueue",function() {
			f("queue");
		});
		var f1 = $bind(this,this.switchTo);
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "methods.switchToTimers",function() {
			f1("timers");
		});
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "methods.copy",$bind(this,this.copy));
		vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "methods.track",$bind(this,this.track));
	}
	setMethodsViewType(viewType) {
		this.viewType = viewType;
		Vscode.commands.executeCommand("setContext","haxeMethodsViewType",Std.string(viewType));
	}
	switchTo(viewType) {
		this.setMethodsViewType(viewType);
		this._onDidChangeTreeData.fire();
	}
	onDidRunHaxeMethod(data) {
		if(!this.enabled) {
			return;
		}
		var rootTimer = data.response.timers;
		if(rootTimer == null) {
			rootTimer = this.makeTimer("",0,[]);
		}
		if(rootTimer.children != null && data.additionalTimes != null && data.response.timestamp != null) {
			rootTimer.children.push(this.createAdditionalTimers(data.additionalTimes,data.response.timestamp));
		}
		var method = data.method;
		this.methods = this.methods.filter(function(item) {
			return item.method != method;
		});
		var item1 = new vshaxe_view_methods_Node(this.context,null,rootTimer,data.method,data.debugInfo);
		this.methods.push(item1);
		this.methods.sort(function(item11,item2) {
			return Reflect.compare(item11.method,item2.method);
		});
		if(this.viewType == "timers") {
			this._onDidChangeTreeData.fire();
			if(this.treeView.visible) {
				this.treeView.reveal(item1,{ select : true});
			}
		}
	}
	createAdditionalTimers(additionalTimes,timestamp) {
		var transmissionTime = additionalTimes.arrival - timestamp * 1000.0;
		var parsingTime = additionalTimes.beforeProcessing - additionalTimes.arrival;
		var processingTime = additionalTimes.afterProcessing - additionalTimes.beforeProcessing;
		return this.makeTimer("vshaxe",transmissionTime + parsingTime + processingTime,[this.makeTimer("display call",additionalTimes.arrival - additionalTimes.beforeCall),this.makeTimer("transmission",transmissionTime),this.makeTimer("parsing",parsingTime),this.makeTimer("processing",processingTime)]);
	}
	makeTimer(name,time,children) {
		var date = new Date(time);
		return { name : name, time : date.getSeconds() + date.getMilliseconds() / 1000.0, children : children};
	}
	onDidChangeRequestQueue(queue) {
		var _gthis = this;
		this.queue = queue.map(function(label) {
			return new vshaxe_view_methods_Node(_gthis.context,null,null,label);
		});
		if(this.viewType == "queue") {
			this._onDidChangeTreeData.fire();
		}
	}
	getTreeItem(element) {
		return element;
	}
	getChildren(element) {
		if(this.viewType == "queue") {
			return this.queue;
		}
		if(element == null) {
			return this.methods;
		} else {
			return element.children;
		}
	}
	copy(element) {
		Vscode.env.clipboard.writeText(element == null ? this.methods.map(function(method) {
			return method.toString();
		}).join("\n\n") : element.toString());
	}
	track(element) {
		if(element != null) {
			Vscode.commands.executeCommand("vshaxeDebugTools.methodResultsView.track",element.method);
		}
	}
}
vshaxe_view_methods_MethodTreeView.__name__ = true;
class vshaxe_view_methods_Node extends vscode_TreeItem {
	constructor(context,parent,timer,method,debugInfo,parentId) {
		if(parentId == null) {
			parentId = "";
		}
		super("");
		this.context = context;
		this.parent = parent;
		this.timer = timer;
		this.method = method;
		this.debugInfo = debugInfo;
		this.children = [];
		this.name = this.formatName();
		this.label = this.formatLabel();
		this.tooltip = this.formatTooltip();
		this.id = parentId + ">" + this.name;
		if(timer == null || timer.children == null) {
			this.collapsibleState = vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.None;
		} else {
			var f = function(context1,parent1,timer1,method1,debugInfo1,parentId1) {
				return new vshaxe_view_methods_Node(context1,parent1,timer1,method1,debugInfo1,parentId1);
			};
			var context2 = context;
			var parent2 = this;
			var method2 = method;
			var parentId2 = this.id;
			var tmp = function(timer2) {
				return f(context2,parent2,timer2,method2,null,parentId2);
			};
			this.children = timer.children.map(tmp);
			this.collapsibleState = vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Collapsed;
		}
		if(this.parent == null) {
			this.iconPath = { light : context.asAbsolutePath("resources/light/method.svg"), dark : context.asAbsolutePath("resources/dark/method.svg")};
		}
	}
	formatName() {
		var name = this.parent == null || this.timer == null ? this.method : this.timer.name;
		if(this.timer != null && this.timer.info != null && this.timer.info != "") {
			name = "" + this.timer.info + "." + name;
		}
		return name;
	}
	formatLabel() {
		if(this.timer == null) {
			return this.name;
		}
		var percent = this.timer.percentTotal != null ? this.truncate(this.timer.percentTotal,4) : null;
		var label = "" + this.name + " - " + this.truncate(this.timer.time,5) + "s";
		if(this.parent != null && percent != null) {
			label += " (" + percent + "%)";
		}
		if(this.debugInfo != null) {
			label += " [" + this.debugInfo + "]";
		}
		return label;
	}
	formatTooltip() {
		if(this.timer == null) {
			return null;
		}
		var now = new Date();
		return "" + ("[" + now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds() + "]") + " " + (this.timer.calls != null ? "" + this.timer.calls + " calls " : "") + "- " + this.truncate(this.timer.time,7) + "s";
	}
	truncate(f,precision) {
		return HxOverrides.substr(f == null ? "null" : "" + f,0,precision);
	}
	toString(indent) {
		if(indent == null) {
			indent = "";
		}
		var result = indent + (this.label == null ? "" : this.label);
		if(this.children != null) {
			result += "\n" + this.children.map(function(child) {
				return child.toString(indent + "  ");
			}).join("\n");
		}
		return result;
	}
}
vshaxe_view_methods_Node.__name__ = true;
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else if (typeof o == 'string') return HxOverrides.strIter(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
if(typeof $global.$haxeUID == "undefined") $global.$haxeUID = 0;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
haxe_ds_ObjectMap.count = 0;
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
sys_io_File.copyBuf = new js_node_buffer_Buffer(65536);
vshaxe_display_DisplayArgumentsSelector.statusBarWarningThemeColor = new vscode_ThemeColor("errorForeground");
vshaxe_display_HaxeDisplayArgumentsProvider.ConfigurationIndexKey = vshaxe__$HaxeMemento_HaxeMementoKey_$Impl_$._new("displayConfigurationIndex");
vshaxe_helper_HaxeExecutable.SYSTEM_KEY = (function($this) {
	var $r;
	switch(Sys.systemName()) {
	case "Mac":
		$r = "osx";
		break;
	case "Windows":
		$r = "windows";
		break;
	default:
		$r = "linux";
	}
	return $r;
}(this));
vshaxe_server_LanguageServer.DontShowOldPreviewHintAgainKey = vshaxe__$HaxeMemento_HaxeMementoKey_$Impl_$._new("dontShowRC2HintAgain");
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
